{"meta":{"title":"空梦博客-个人博客","subtitle":null,"description":"空梦的个人博客；主攻 Java、爬虫、WEB前端、数据库、数据分析、数据可视化 前后端框架；求知若饥，虚心若愚，一入 IT 深似海，从此学习无绝期，记录毕生所学！","author":"Mr. 空梦","url":"https://kmbk0.top"},"pages":[{"title":"404 Not Found","date":"2020-01-06T04:49:41.413Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"404.html","permalink":"https://kmbk0.top/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2020-01-15T15:58:21.229Z","updated":"2020-01-15T15:58:21.229Z","comments":true,"path":"friends/index.html","permalink":"https://kmbk0.top/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 空梦博客头像： https://cdn.jsdelivr.net/gh/Wbiubiu/kmbk-cdn/favicon/km.png网址： https://kmbk0.top标签： 【这里就写你博客类型】"},{"title":"","date":"2020-01-06T04:49:42.429Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"projects/index.html","permalink":"https://kmbk0.top/projects/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-08T11:52:13.627Z","updated":"2020-01-08T11:52:13.627Z","comments":true,"path":"about/index.html","permalink":"https://kmbk0.top/about/index.html","excerpt":"","text":"空梦博客一个小小的个人站， ㊣━━^-^o中华人民共和国o^-^━━㊣┃ 宠 粉 本 科 ┃┃ 毕 业 证 ┃㊣━━^-^o中华人民共和国o^-^━━㊣"},{"title":"所有分类","date":"2020-01-06T04:49:42.306Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"blog/categories/index.html","permalink":"https://kmbk0.top/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-06T04:49:42.348Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"blog/tags/index.html","permalink":"https://kmbk0.top/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用material-x主题如何自定义添加侧边栏小部件？","slug":"使用material-x主题如何自定义添加侧边栏小部件？","date":"2020-01-11T10:01:35.000Z","updated":"2020-01-14T09:58:06.477Z","comments":true,"path":"2020/01/11/使用material-x主题如何自定义添加侧边栏小部件？/","link":"","permalink":"https://kmbk0.top/2020/01/11/使用material-x主题如何自定义添加侧边栏小部件？/","excerpt":"使用material-x主题如何自定义添加侧边栏小部件？ 究竟如何添加？我们来一起看看吧！","text":"使用material-x主题如何自定义添加侧边栏小部件？ 究竟如何添加？我们来一起看看吧！ 描述先上Material X主题官网 戳我进官网 ^_^#&nbsp;官方文档 戳我进官方文档官方主题开源网站 戳我赢大奖啊ヽ(≧Д≦)ノ 注:我在这里就不多说了，对于如何搭建的想必你也知道怎么搭建。对于不知道如何搭建的朋友请看我前面的文章希望可以帮到你！好了，我也就不废话了。我们开始吧！ 开始教程第一步首先我们需要在主题的这个[\\themes\\material-x\\layout_widget]目录下创建你需要的新添加的侧边栏小部件的的名字xx.ejs&nbsp; 例如：tq.ejs &nbsp; 如下图 相应的目录下新建了一个tq.ejs 的文件 第二步在新建的tq.ejs写入你的自己需要添加的小部件配置代码了，我这里就拿我的侧边栏天气的插件做案例吧！ 以下是代码1234567&lt;section class=&apos;widget &lt;%- item.widget?item.widget:&apos;tq&apos; %&gt;&apos;&gt; &lt;%- partial(&apos;header&apos;, &#123;item: item, defIcon: &apos;&apos;, defTitle: &apos;&apos;&#125;) %&gt; &lt;div class=&apos;content &lt;%= theme.style %&gt;&apos;&gt; &lt;%- markdown(item.body) %&gt; &lt;/div&gt;&lt;/section&gt; 如下图 第三步写入代码完成后我们就要去主题文件下的_config.yml文件下配置啦！ 目录[\\themes\\material-x_config.yml] 这里呢，也是一样的我们需要新建一个widget 这个字段在官网也有教程，我们在这里也就不多说了哈~ (๑乛◡乛๑) 以下是代码12345- widget: tq icon: fas fa-cloud title: 天气预报 body: &apos;&lt;iframe name=&quot;weather_inc&quot; src=&quot;https://i.tianqi.com/index.php?c=code&amp;amp;id=7&quot; width=&quot;100%&quot; height=&quot;100&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;padding-left: 10px;&quot;&gt;&lt;/iframe&gt;&apos; 如下图 这里介绍一下widget以下所用到的字段： icon 小部件的左上角的图标 title小部件的名称 body小部件所需要的配置文件代码 闲言碎语这里都配置完成后我们就去使用。如何使用呢？这时就要看配置文件里面的说明了！或者看官方文档也是可以的，但是呢有很多人看不懂官方文档主要写的太官方化，这让我们这些小白何以理解啊！嘿嘿！(๑乛◡乛๑)&nbsp;(小声bb)m(-_-m)～你特喵的还废话~&nbsp;还不赶紧继续写教程。。。。 咳咳，话不多说开干！命苦啊！(ㄒoㄒ) 第四步这一步呢其实挺简单的，也就像是java对象进行调用就行了 &nbsp; (等会，说什么java啊！写的是hexo博客教程还跑去java了。。.(→_→)一脸嫌弃) 好好，我们言归正传哈！ 这么也就是调用一下刚刚写的那个widget字段配置就行了！这里说一下啊！官方给了我们自由选择的模式添加，例如在主页面的侧边栏添加啊、或者文章页面啊！等等。。这个看自己好吧，看自己需求自由发挥添加，毕竟谁都不想一直跟着别人走啊，总要玩点自己的新花样吧！Σ(ＴωＴ)努力– 如下图 这里是主题目录下的_config.yml配置 可以看到,这里我添加的两处位置，一个是主页，一个是文章的侧边栏 仔细看图中有红色圈圈的就可以明白了！已经注明很清楚了！ 问答 问：有盆友问我，这就完了？这么简单？？？ 答：别着急嘛！最开始我也是这样认为但是呢？其实不是的，这样的话你是无法展示出来的，代码是也不会生效。其实一开始我也是这样认为的，但是在我测试的时候却不是我想的那样。。。咋办捏，这时我们就要去考虑一个问题了，既然是新添加的小部件那我们肯定要去配置哪些小部件是生效的哪些不是，那么问题来了。这个主题配置究竟是不是这样子的呢？谁也说不准那就让我们继续往下看吧！ 第五步 闲言碎语看到这里我们就要执行最后一步的配置啦！(是不是很开心！我也要成功啦！其实是废话真tm多，感觉自己像一个 S* &nbsp;一样m(-_-m)～)咳咳，让我们言归正传 ，(其实归正几次了，都被我跑遍了！ 好了，不说这些了！) 首先呢这第五步啊！就是要在主题目录的[\\themes\\material-x\\layout_partial] 路径下找到side.ejs side：意思就是侧面、旁边然后进行添加我们自己新建的小部件，这里通俗点说，也就是需要在这里激活你所新建的小部件。如下图 图中所示：找到主题目录文件夹下的side.ejs 图中所示：添加的新键的tq小部件的调用 好了，这呢。也算是完成了！我们快去试试吧！ (此时此刻都已经按耐不住我那迫不及待的小心脏了！O(∩_∩)O 想要赶紧去一探究竟啦！) 我们在git 执行以下命令123hexo cleanhexo generatehexo deploy 好，执行完去看页面看效果！ 最后的效果 快看，我们成功了~ 问题是不是解决了？ 哈哈哈！所有的努力没白费！ 总结 闲言碎语 好啦，本次教程到此处就已经结束了，此教程呢也是为小白打基础所发布的，再说连小编我也是小白啊！( ＾∀＾) 本是同根生，相煎何太急。(释义：煮豆来做豆羹，过滤的豆子做成汁。豆杆在锅下燃烧，豆子在锅里哭泣。豆杆和豆子本是从同一条根上生长出来的，为什么要相互煎熬逼迫得那么狠呢？) 虽说油炸起来比较香一些。。。但是…(你tm 又跑偏了！你在总结，总结。回来) 哈哈！真S* 我们言归正传 (呃，这个 好像归了好几次了… 算了，三分归元气嘛~ )好，话题结束 本次总结我们在做新建小部件或者插件的时候，需要考虑的问题也就是这个配置到底是不是会自动配置为我们所调用呢？经过我们一番测试来看，我们上面的猜测是对的。这个主题呢~ 官方写的是死的，也就是说必须指定那些已经配置过的小部件然后才能调用和使用，所有呢我们在新建部件的话就要按照这个方法进行配置自行添加自己新建的部件啦！ 好啦，本期文章到此结束啦！(哎哟，可算结束了，累死我了！又是上传图片、又是打字总结的，嘘！这话不要讲，这么多朋友肯定会给你动力啊！加油！)如果您觉得有什么问题可以在下方留言哦！本帖留言已开！ 好了，今天就说这么多，我们下期再见！拜拜！","categories":[{"name":"记录","slug":"记录","permalink":"https://kmbk0.top/blog/categories/记录/"},{"name":"教程","slug":"记录/教程","permalink":"https://kmbk0.top/blog/categories/记录/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kmbk0.top/blog/tags/Hexo/"},{"name":"主题优化","slug":"主题优化","permalink":"https://kmbk0.top/blog/tags/主题优化/"},{"name":"配置","slug":"配置","permalink":"https://kmbk0.top/blog/tags/配置/"}]},{"title":"Markdown简明语法","slug":"Markdown简明语法","date":"2020-01-06T00:35:56.000Z","updated":"2020-01-14T12:52:59.836Z","comments":true,"path":"2020/01/06/Markdown简明语法/","link":"","permalink":"https://kmbk0.top/2020/01/06/Markdown简明语法/","excerpt":"","text":"#Markdown简明语法 Markdown是一种可以让人专注于内容与代码的轻量级的【标记语言】。让我们离开那些繁琐的排版与样式，专注于内容吧！！！ 标题在Markdown中，标题是使用 1-6个# 进行标记，分为六级：# 、##、###…… ，刚好对应h1~h6: 一级标题二级标题三级标题四级标题五级标题六级标题 区块与段落区块则是使用 &gt; 来进行标记： 这是一个区块啊！！！！ 可以通过首尾个空一行来形成一个段落，也就是类似于在HTML中以 &lt;p&gt;标签包起来：（注：官方语法推荐在标记的后面加入一个空格） 这是一个段落啊！我被&lt;p&gt;包住啦！ 有序列表与无序列表学过HTML的同学一定知道 &lt;li&gt;和&lt;ol&gt;,而在MD中，无序列表可以用 */+/-来进行标注：（通过行首加入tab，可标记二级列表） 小米 华为 苹果 oppo vivo 而有序列表则直接使用数字进行标记： 品牌 电器 物品 强调输出为HTML中的 &lt;strong&gt;\\&lt;em&gt;，使用 *和**包住强调的部分： 你好！我是一个 强调 哦！！你好！我是一个比你还厉害的二级 强调 哦！ 链接输出为HTML中的 &lt;a&gt;标签，使用 []直接包裹链接部分，后直接跟上()填入链接到的地址（也可以在地址后面 空格+title）： 你好！我叫度娘 戳我一下去我家啊； 图片输出为HTML中的 &lt;img&gt;标签，用法与标记链接基本一致： 我是一张图片](https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/17.jpg&quot;Title&quot;)； 代码块当你需要在文章中添加代码时，比如 &lt;p&gt;hello world&lt;/p&gt; ，如果直接输入，则会变成 hello world p标签被直接翻译吃掉啦！因此，我们需要对代码块进行特殊的标识： 行内代码块： 使用反引号进行包裹： &lt;p&gt;hello world&lt;/p&gt; 块状代码块：使用tab对整体代码进行缩进； 1&lt;p&gt;hello world&lt;/p&gt; 表格MD的表格有点好玩，其实就是使用 |画出一个表格来，但其实这有点小麻烦： Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 小结熟练的使用上述的这些规则，应该就能应付平时的日常使用了，除了表格比较麻烦外，其它都简单易用。但需要多多联系，熟能生巧嘛。~在日后写博客的过程中，慢慢的掌握它！加油哦~~~","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://kmbk0.top/blog/tags/Markdown/"}]},{"title":"JavaScript语言编程核心（四）--- 函数（待完成）","slug":"JavaScript语言编程核心(四)—函数(待完成)","date":"2019-12-16T05:21:00.000Z","updated":"2020-01-14T12:52:29.761Z","comments":true,"path":"2019/12/16/JavaScript语言编程核心(四)—函数(待完成)/","link":"","permalink":"https://kmbk0.top/2019/12/16/JavaScript语言编程核心(四)—函数(待完成)/","excerpt":"","text":"JavaScript语言编程核心（四）— 函数（待完成）在编程过程中，我们很经常会需要多次使用到一段代码，此时便需要把这段代码定义成函数，从而可以调用任意次。 函数是JavaScript中最出色的设计之一，它们是JS中基础模块单元，可用于代码复用，信息隐藏和组合调用。JS中的函数就是对象，也拥有自己的方法，它连接到Function.prototype上。 本文参考《JavaScript权威指南》； 函数的定义一般有两种方式可以创建函数：函数声明与函数表达式； 函数声明：123function add(a,b)&#123; return a+b;&#125; 这种形式的声明会被提前到作用域的顶部，所以可以在被定义之前调用它，称为 声明提前； 函数表达式：123var add = function(a,b)&#123; return a+b;&#125; 表达式的形式并不能在定义之前调用它，虽然var add也会被提前到作用域顶部，但赋值语句并不会被执行，此时add扔为undefined，所以只有在表达式定以后，才能进行函数的调用。 Tips：1、函数声明可以出现在全局代码中，也可以被嵌套在其它函数内，但根据规定，不能出现在循环，判断，try/catch/finally与with语句中。而函数表达式可以出现在任何地方。 2、定义在其它函数内部的函数，包含一个连接到外部上下文的连接[[scope]]，可以自由访问它的父函数中的参数与变量，这便是JS中的 闭包。 函数的调用调用一个已经定义好的函数有4种方式，会传入 实参，this, arguments。 1、函数调用模式可以直接在函数名称的后面加上()，传入参数完成函数的调用，如add(3,4)；此时，根据ES5或者ES5非严格模式，调用上下文( this )被指向全局对象；而在ES5严格模式中，this 则为 undefined； 因此可以这样来检测是否为严格模式：1var strict = (function()&#123;return !this;&#125;)(); 2、方法调用模式当一个函数被保存成一个对象的属性时，则成为一个方法，此时 this 指向保存该函数的对象。如 object.method()； 多数情况下，可以直接用 .符号来直接访问，但少数情况下可能需要使用[ ]来进行属性的访问操作。 方法链也称为 链式调用或级联调用，我们可以在一个方法中返回一个对象，从而可以继续调用它的方法。如JQuery中就是这么实现的；1$(&quot;.header&quot;).map().get().sort(); 这将使代码变得更为简洁和易读，因此当方法不需要返回值时，最好直接返回this。 thisthis是函数中的一个关键字 ，它指向函数的调用上下文，并不是变量，也不是属性名，因此不能对其进行赋值。 如果作为方法调用函数，则this指向保存该方法的对象； 如果在函数调用中，this可能指向全局或者undefined，因此，在闭包中，如果想访问父级的this，则通常是将this保存在一个变量里，便可以通过作用域链进行访问，一般可以命名为 self/that/me。 this总结： 1、全局环境中，则指向 全局对象（windows）。 2、构造函数里的this，则指向 新创建的对象； 3、函数中的this，指向 函数的调用者； 4、new Function，指向 全局对象（windows）; 5、eval中，指向调用上下文中的this； 构造函数调用模式如果函数或者方法调用之前带有关键字 new，它就构成构造函数式调用。构造函数的处理方式跟普通的调用在实参处理、调用上下文和返回值方面都有着不同。 1、当构造函数没有形参时，可以省略实参列表和圆括号； 2、new操作符的操作步骤可以分成3步： （1）创建一个新对象； （2）新对象继承构造函数的prototype属性，this指向该新对象，也就是说，就算即使使用new o.m()，函数中的this值也是指向新对象，而不是o； （3）执行函数语句，为新对象添加属性，方法； （4）返回该新对象；通常，构造函数中不适用return，但如果有主动return一个对象，则返回该对象；如果没有返回或者返回一个原始值，则返回最初创建的对象； 间接调用使用call()和apply()可以间接地调用函数，它们可以显式地指定this值，也就是说，任何函数都可以作为任何对象的方法来调用。 call(this,p1,p2,p3)：以自己的实参列表作为传入函数的实参；apply(this,[p1,p2,p3])：以数组的形式传入实参； 函数的实参与形参1、实参数量少于形参调用函数时，当实参的数量少于定义的形参时，则后面的形参的值均为undefined。因此，在设置形参的时候，理想的情况是为参数设置一个合理的默认值，可以使用下面的形式：1a = a || 0; // 形参设置为 a 但传入的实参和形参只是以顺序的位置对应，并无法主动地为他们指定关系，也就是说，无法省略第一个实参，而直接传入第二个实参，必须填入占位的undefined或者null，因此可选的形参只能放在是参列表的最后。推荐对可选参数进行清晰的注释。 2、实参数量多于形参调用函数式，当实参的数量大于定义的形参时，可以通过参数对象来获取超过部分的实参。这个对象称为 arguments，是一个类数组，包含着传入的所有实参列表，它可以通过类似于数组的[0],[1]进行索引，访问传入的实参。同时，它还拥有可以length的属性，可以获取到传入函数的实参数量。 该对象有一个重要的用处，既让函数可以处理不定数量的实参，这种函数也成为 不定实参函数（varargs function）。比如，求任意个数字的总和，便可以定义为：12345678910111213var add = function()&#123; var sum = 0, i; l = arguments.length; // 遍历实参对象，累加每一个实参； for(i=0;i&lt;l;i++)&#123; sum += arguments[i]; &#125; // 返回结果； return sum;&#125;var sum = add(1,2,3,4,5); // sum为15； Tips:1、实参对象arguments其实是实参的一个指针数组，并不是一个真正的数组，也就是说，上面函数中，arguments[0] === 1的值为 true。在非严格模式下，可以通过实参对象来修改传入函数的实参的值。 2、实参对象还包含两个值，callee和caller。在严格模式下，不能对这两个值进行读写操作，但在非严格模式下，callee指向当前函数本身，caller则指向调用函数的函数。 3、记住定义的形参顺序，是个麻烦的事，因此可以使用直接传入对象，对象中是一个所有参数的键值对集合。 4、合理的实参类型检测，是避免函数执行错误的保证。 自定义函数属性由于函数的本质也是一个特殊的对象，它也可以拥有自己的属性。当有些函数需要一些静态的值时，其实可以将其保存在函数的自身属性中，从而避免保存到全局环境中。12345678function integer()&#123; return integer.counter++;&#125;integer.counter = 0;// 点击一次，计时器累加1；$(document).on(&quot;click&quot;,function()&#123; console.log(integer());&#125;) 作为命名空间的函数一般，我们会避免在全局环境中添加变量，避免污染全局的命名空间，一个很好的解决方法，便是将代码放置于一个函数作用域内。一般使用匿名的立即执行函数：123(function()&#123; // 模块代码;&#125;)();","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"JavaScript语言编程核心（三）--- 执行上下文与作用域","slug":"JavaScript语言编程核心(三)—执行上下文与作用域","date":"2019-12-05T00:21:00.000Z","updated":"2020-01-14T12:51:00.278Z","comments":true,"path":"2019/12/05/JavaScript语言编程核心(三)—执行上下文与作用域/","link":"","permalink":"https://kmbk0.top/2019/12/05/JavaScript语言编程核心(三)—执行上下文与作用域/","excerpt":"","text":"JavaScript语言编程核心（三）— 执行上下文与作用域执行上下文（EC）执行上下文：可以抽象为一个简单的对象，在一个函数或者eval( )被执行时创建，对象里面包含着一些代码运行所需的属性，统称为 上下文状态。一个上下文状态由三个结构组成： 变量对象(variable Object); 作用域链(scope chain)； this指向(thisValue)； 执行上下文堆栈一般可以认为有三种执行上下文： 全局执行上下文； 函数执行上下文； eval执行上下文； 一个执行上下文可以触发另一个上下文，以栈的形式实现，称为执行上下文堆栈。 触发其它上下文的叫做 caller，而被触发的上下文叫做 callee； 1.当代码执行的时候，首先生成一个全局执行上下文（global EC）。 2.当执行到函数作用域时，全局执行上下文（caller）会触发该函数执行上下文(callee)，将控制权传递给callee，而此时caller则暂缓执行。callee被push到栈的最顶层，拥有控制权，成为当前运行的执行上下文(active EC)。 3.当callee执行结束后，控制权会返还给caller，callee从栈顶层被pop除，caller继续往下执行。 变量对象(VO)变量对象是执行上下文中的一个数据作用域，存储着上下文中所定义的变量和函数声明（不包括函数表达式）。 全局上下文的变量对象就全局对象本身。 活动对象（AO）当函数被caller触发时，该函数的变量对象（VO）则会被激活成为活动对象（AO），里面加入了形参和arguments对象。 作用域作用域：通俗点可以理解为是一段代码或者一个变量的作用范围，是程序源代码中定义这个变量的区域，可以简单的理解为一个对象，其实，变量对象便是作用域的实体。比如，一个全局变量，就拥有全局的作用域，在JavaScript代码的所有地方都有定义，都可以进行访问，理解为一个全局对象中定义着这个全局属性。 在许多编程语言中，每个花括号中的代码都具有各自的作用域，而在花括号的外部，是不可见的，这称为 块级作用域(block scope)。但在JavaScript中，虽然语法上也是使用花括号，但并不存在块级作用域，在花括号内定义的变量，在外部都是可见的。取而代之的是函数作用域(function scope)：在一个函数中声明的变量，在该函数，包括其内部嵌套函数中，都是有定义，可见的。但在函数的外部是不可见的。 因此，这里就引出了另一个概念– 声明提前。根据函数作用域的定义，一个声明在函数体内的任何地方都是始终可见的，甚至在声明之前。因此，就算在声明一个变量之前，也是可以访问到这个变量的（但不涉及到赋值）。1234567var scope = &quot;global&quot;;(function()&#123; // 并不是输出global，这是因为声明提前，等于在该语句前加了一句，var scope。但并不涉及赋值； console.log(scope); // undefined； var scope = &quot;local&quot;; console.log(scope); // local;&#125;)(); 作用域链在定义一个函数作用域时，会随之产生一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表，列表内包含所有父级变量对象和自身的活动对象，另外，通过with语句和catch语句也可动态的延长作用域链。 作用域链其实是由两部分组成的：函数内部属性 [[scope]] + 自身活动对象(AO)；在[[scope]]属性中，保存着父级函数的作用域链。 当在函数内访问一个变量时，首先会从该函数自身的活动对象中查找，如果不存在，则会沿着作用域链往上一级一级查找父级变量对象。 闭包由于在JavaScript中，函数属于第一级对象，即可以当成参数传入一个函数，也可以从函数中返回出一个函数。此时，便会出现一个问题，当一个父函数执行后返回另一个子函数后，便会被摧毁，而此时，返回的子元素的[[scope]]属性中仍然保存着父函数的作用域链，以此来解决访问父函数中变量的问题。 这种类型的作用域，成为静态（词法）作用域。12345678var afun = (function()&#123; var a = 1; return function afun()&#123; alert(a); &#125;&#125;)();var a = 2;afun(); // 1 静态作用域是闭包存在的一个必需条件，因此 闭包可以定义为： 一个函数，和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。 Tips：从理论上讲，每一个函数都可以称为闭包，因为都包含了[[scopte]]属性。 当在一个父函数中定义了两个子函数时，此时两个子函数拥有相同的[[scope]]属性，而且是共享的。也就是说，改变一个闭包中的变量，会影响到另一个闭包中的变量。这也就是我们最常见的闭包问题的根源所在：12345678910var a = [];for(var i = 0;i&lt;10;i++)&#123; a[i] = function()&#123; console.log(i); &#125;&#125;// 而不是预期中的 0~9，其原因就是这9个函数共享一样的[[scope]]属性；a[0](); // 10;a[1](); // 10;a[9](); // 10; 可以通过将参数i以参数的形式传入，让其不需要从[[scope]]属性中进行查找。1234567891011var a = [];for(var i = 0;i&lt;10;i++)&#123; a[i] = (function(x)&#123; return function()&#123; console.log(x); &#125; &#125;)(i);&#125;a[0](); // 0;a[1](); // 1;a[9](); // 9;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"JavaScript语言编程核心（二）--- 代码的复用模式","slug":"JavaScript语言编程核心(二)—代码的复用模式","date":"2019-12-03T04:01:00.000Z","updated":"2020-01-14T12:51:58.154Z","comments":true,"path":"2019/12/03/JavaScript语言编程核心(二)—代码的复用模式/","link":"","permalink":"https://kmbk0.top/2019/12/03/JavaScript语言编程核心(二)—代码的复用模式/","excerpt":"","text":"JavaScript语言编程核心（二）— 代码的复用模式在大多数编程语言中，代码复用都是很重要的一块内容，而代码的继承性，是代码复用的一种重要形式，可以显著地减少开发成本，提高开发效率。继承的方式可以大致的分成两类：1、传统的类式继承；2、现代化继承方式：包括原型继承、复制属性继承、混入、借用、借用与绑定。 构造函数在JavaScript中，构造函数其实也是一类普通函数，但它有几个特点： 1、函数名首字母大写，以区分普通函数；2、通过this创建新的属性和方法；3、配合new操作符，可创建出一个新对象； new操作符new操作可以配合函数，返回一个对象，实际上它是做了三件事情： 1、创建一个新对象； var _obj = {}；2、使_obj继承该函数的原型；obj.__proto__ = CO.prototype;3、执行函数中的语句，为this指向添加属性、方法；4、返回该新对象； Tips：如果函数中有主动return一个对象，则返回该对象，否则隐式返回_obj;如果忘记使用new，则会造成在全局中添加属性和方法，这是很糟糕的。因此不要忘记new！为了避免当忘记new时，不会出现意外，便出现了一种模式，称为 自调用构造函数，它可以使得 var a = new CO()与var a = CO()效果一致；123456789function Person()&#123; if(!(this instanceof Person))&#123; return new Person(); &#125; this.name = &quot;dong&quot;;&#125;Person.prototype.sayName = function()&#123; alert(this.name);&#125; 类式继承实现类式继承的目标，是通过构造函数Child( )来获取一个父类构造函数Parent( )的属性，然后再由new Child( )实例化对象，实现继承。因此，关键的步骤就是 inherit(Child,Parent); 这里，有多种模式可以完成这样的继承函数： 1、默认模式：123function inherit(c,p)&#123; c.prototype = new P();&#125; Tips:对象指向原型，使用对象内部的__proto__属性，指向一个实例对象。但该属性不符合W3C标准，不能使用，但可以让我们更好的理解JS的原型继承的概念；构造函数指向原型，使用prototype属性，也是指向一个实例对象；通过默认模式完成的继承，属性与方法并不在自身上，只是通过原型链查找到的，仅仅是获取到引用，而且无法通过子构造函数传参。 2、借用构造函数：123function Child(a,b,c,d)&#123; Parent.apply(this,arguments);&#125; 该方法是只可以继承父级构造函数中添加到this的属性，原型中的属性并不能继承。但相比于第一种默认方式，它继承的属性都变成了自身属性，即hasOwnProperty为true，而不是从原型链上查找到的属性。 通过该模式，可以实现多重继承，即同时继承多个父级函数的属性；1234function Child()&#123; Father.apply(this,arguments); Mother.apply(this,arguments);&#125; 该模式的优点是，继承后的子级是父级函数的真实副本，操作子级函数并不会影响或覆盖父级函数。而缺点，便是无法从原型中继承属性，而是为每个实例都初始化各自的方法属性。 借用与设置原型为了解决借用模式的缺点，我们可以为其设置原型来解决。1234function Child()&#123; Parent.apply(this,arguments);&#125;Child.prototype = new Person(); 这样既能得到父级函数中属性的真是副本，又可以继承到原型上的方法。但仍然是有缺点，便是该模式调用了两次Parent构造函数，属性被继承了两次，导致了效率的低下。 共享原型该模式有点类似于第一种默认方式，但是不同点在于，将子函数的原型直接指向父级构造函数的原型。123function inherit(c,p)&#123; c.prototype = p.prototype;&#125; 只要将要复用的属性，方法都放在父级的原型里，即可以达到继承的目的。但是该模式的缺点在于，当修改了继承的子级的原型时，便直接影响到了该类中的所有对象。 代理构造函数模式通过创建一个代理构造函数，链接父级函数的原型与子级函数，从而避免了共享原型所带来的弊端，而且可以利用原型链的优势。12345function inherit(c,p)&#123; var F = function()&#123;&#125;; F.prototype = p.prototype; c.prototype = new F();&#125; Tips：该模式不会继承父级构造函数上this的属性，只会继承父级原型上的属性。更近一步，可以将父级构造函数和其原型的存为子级构造函数的一个指针，以备不时之需；12c.uber = p.prototype;c.prototype.constructor = c; 综上可以整理出最后，也是JS中较为完美的类式继承模式，也称为 圣杯模式；最后一点优化，便是使用即时执行函数和闭包，优化每次都需要创建一个新的代理函数的缺点。 圣杯模式123456789var inherit = (function(c,p)&#123; var F = function()&#123;&#125;; return function(c,p)&#123; F.prototype = p.prototype; c.prototype = new F(); c.uber = p.prototype; c.prototype.constructor = c; &#125;&#125;)(); Klass语法糖12345678910111213141516171819202122232425262728293031323334var klass = function(Parent,props)&#123; var Child,F,i; // 1. // 新构造函数； Child = function()&#123; if(Child.uber &amp;&amp; Child.uber.hasOwnProperty(&quot;__construct&quot;))&#123; Child.uber.__construct.apply(this,arguments); &#125; if(Child.prototype.hasOwnProperty(&quot;__construct&quot;))&#123; Child.prototype.__construct.apply(this,arguments); &#125; &#125; // 2. // 继承; Parent = Parent || Object; F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.uber = Parent.prototype; Child.prototype.constructor = Child; // 3. // 添加实现方法： for(i in props)&#123; if(props.hasOwnProperty(i))&#123; Child.prototype[i] = props[i]; &#125; &#125; // 4. // 返回该Child; return Child;&#125; 现代化继承方式1、原型继承：对象可以通过为它指定原型对象而完成继承，这样的继承称为委托继承，也可以称为原型继承。原型对象也是一个简单的对象，此时也可以继续为它指定它的原型对象而完成继承。此时，由 实例对象 —&gt; 原型对象 —&gt; 原型对象…，这样构建出来的一条线，便称为原型链。 原型链：是由原型对象组成，是一个用来实现继承和共享属性的有限的对象链。 属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined； 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用：b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。 1、通过__proto__来实现原型继承，从测试代码可以看出，b对象继承了a对象的x属性，同时a对象继承于顶级的原型对象 Object.prototype。因此则组成了一条原型链： b —&gt; a —&gt; Object.prototype;1234567// var a = &#123;x:1&#125;;var b = &#123;&#125;;b.__proto__ = a;console.log(b.x); // 1；console.log(a.__proto__ == Object.prototype); // true;console.log(b.__proto__ == Object.prototype); // false; 2、第二种方式可以使用ES5中的Object.create( )方法来实现原型的继承：也就是可以通过给一个函数F，直接通过prototype指定一个实例对象作为原型，完成继承。1234567891011// 低版本浏览器的兼容；if(!Object.create)&#123; Object.create = function(o)&#123; if(arguments.length&gt;1)&#123; throw new Error(&quot;只接受第一个参数&quot;); &#125; function F()&#123;&#125;; // 创建一个新对象； F.prototype = o; // 将新对象的原型对象指向传入对象； return new F(); // 返回该对象的实例； &#125;&#125; 2、通过复制属性实现继承这种模式中，对象将从另一个对象中以直接复制的形式继承属性，可以由一个extend( )实现复制继承。 浅复制：如果对象中的属性是对象，那只是简单的进行引用的复制。会导致修改子对象的对象属性，则父对象的属性也会被修改；1234567891011function extend(parent,child)&#123; var i; child = child || &#123;&#125;; // 遍历父对象的属性，判断是否为自身属性； for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; child[i] = parent[i]; &#125; &#125; return child;&#125; 深复制：以浅复制的形式，增加判断，当遇到属性是对象时，则递归进行更深一步的复制；1234567891011121314151617function extendDeep(parent,child)&#123; var i, toStr = Object.prototype.toString; child = child || &#123;&#125;; // 遍历父对象属性，先判断是否为自身属性，后属性值判断是否为对象； for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i] === &quot;object&quot;)&#123; child[i] = (toStr.call(parent[i]) === &quot;[object Array]&quot;?)[]:&#123;&#125;; extendDeep(parent[i],child[i]); &#125;else&#123; child[i] = parent[i]&apos;&apos; &#125; &#125; &#125; return child;&#125; 3、混入模式所谓的混入模式，就是将多个对象进行合并，组成一个新对象，该对象拥有对象的所有属性，可以建立一个mix函数进行混入，也仅为浅复制模式；12345678910111213function mix()&#123; var i, prop, child=&#123;&#125;; for(i=0;i&lt;arguments.length;i++)&#123; for(prop in arguments[i])&#123; if(arguments[i].hasOwnProperty(prop))&#123; child[prop] = arguments[i][prop]; &#125; &#125; &#125; return child;&#125; 4、借用方法有时，并不需要达到继承，只是需要借用一两个方法。该情况下，可以使用apply( )与call( )方法。这两个函数可以改变函数中的this指向，两者的区别在于传入的第二个参数。12parent.doSomething.call(child,p1,p2,p3);parent.doSomething.apply(child,[p1,p2,p3]); 5、借用和绑定有时仅仅使用借用方法，会导致一些意想不到的错误，如：12var sayName = one.say;sayName(&apos;ho!&apos;)； // 由于this的指向全局对象，会导致出错； 此时，便需要有个绑定的方法来将一个对象与一个方法绑定：123456function bind(o,m)&#123; return function()&#123; // slice方法不传参数时，将伪数组转换成数组； return m.apply(o,[].slice.call(arguments)); &#125;;&#125; 该方法的代价便是额外的闭包开销；","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"JavaScript语言编程核心（一）--- 对象","slug":"JavaScript语言编程核心(一)—对象","date":"2019-12-01T02:01:35.000Z","updated":"2020-01-14T12:50:36.293Z","comments":true,"path":"2019/12/01/JavaScript语言编程核心(一)—对象/","link":"","permalink":"https://kmbk0.top/2019/12/01/JavaScript语言编程核心(一)—对象/","excerpt":"","text":"JavaScript语言编程核心（一）— 对象对象这是系列关于js语言核心思想的一些理解，包括对象、继承、原型链、构造函数、执行上下文堆栈、执行上下文、变量对象、活动对象、作用域链、闭包以及this。 本文参考自《JavaScript权威指南》、《JavaScript语言精粹》以及前端早读君的文章《javaScript核心》。 对象在JavaScript中，对象是指可变的键控集合。属性名为字符串，值可以为任何类型的javascript值，每个属性都是一个名/值对。除了可以拥有属性外，对象还可以从一个称为原型的对象中继承属性。这就是JavaScript中的 “原型式继承”。 1、属性特性：在ES5中，属性还包括了一些标识可写、可枚举和可配置的特性。可以通过这些API给原型对象添加方法，并设置成不可枚举，让它们更像内置方法，也可以给对象定义不能修改或删除的属性，“锁定”该对象。获取和定义可使用 getOwnPropertyDescriptor 和 defineProperty 方法：123456789var o = &#123;&#125;;Object.defineProperty(o,&quot;x&quot;,&#123; value:2, writable:true, // 可写性； enumerable:false, // 可枚举性； configurable:true // 可配置性;&#125;);console.log(Object.getOwnPropertyDescriptor(o,&quot;x&quot;));console.log(o.x); 可写，表明是否可以设置改属性的值； 可枚举，表明是否可以通过for/in循环返回； 可配置，表明是否可以删除或修改该属性； 2、对象特性： 对象的原型属性（prototype）通过隐含的__proto__属性指向另一个对象，可以继承原型对象的属性；12Object.getPrototypeOf( ) // 可查询对象的原型；p.isPrototypeOf(o) // 来检测p是否是o的原型； 对象的类（class）是一个表示对象类型的字符串，用以表示对象的类型信息，一般用toString( )来获取：[Object class]。下面是封装好的 classof函数，用来检测对象类型；12345function classof(o)&#123; if(o === null)&#123;return &quot;Null&quot;&#125;; if(o === undefined)&#123;return &quot;Undefined&quot;&#125;; return Object.ptototype.toString.call(o).slice(8,-1);&#125; 对象的扩展标记（extensible flag）指明了是否可以向该对象添加新属性；ES5中，所有的内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是依据引擎所定义的；123456Object.esExtensible( ); // 判断对象是否可扩展；Object.preventExtensions( ); // 将对象设置为不可拓展并且无法再转换回可拓展；但同样可以继承属性；Object.seal( ); // 封闭对象；将对象设置为不可拓展，而且将所有自有属性设置为不可配置；Object.isSealed( ); // 检测对象是否被封闭；Object.freeze( ); // 更严格的冻结对象，不可拓展，配置，且只读；Object.isFrozen( ); // 检测对象是否被冻结； 3、对象的分类： 内置对象：JS内部定义的对象或类，如数组（Array）、函数（Function）、日期（Date）和正则表达式（RegExp）等； 宿主对象：由js解释器所嵌入的宿主环境中定义的对象，如浏览器客户端； 自定义对象：在JS代码中创建的对象； 4、对象属性的分类： 自有属性：在对象内部定义的属性； 继承属性：从原型对象中继承得到的属性； 5、 对象的创建： 对象字面量法：一个对象字面量就是包围在一对花括号中的若干个名/值对组成的映射表，名与值之间用:分隔，名值对间用,分隔。该方法的__proto__指向Object.prototype.12345// 注意，最后一个名/值对后不再添加逗号；var student = &#123; &quot;name&quot;:&quot;Tayde&quot;, &quot;age&quot;:26&#125; new操作符+构造函数：通过new操作符后跟一个函数，初始化创建出一个新的对象，该方法的__proto__指向构造函数.prototype。1var o = new Object(); // 与 var o = &#123; &#125;效果一样； ES5中的Object.create( ):该方法可填两个参数，第一个填对象原型，第二选填自定义的属性；__proto__指向函数中填入的对象。1var o1 = Object.create(&#123;x:1,y:2&#125;); // 则o1对象已经继承了x,y属性； 6、对象属性的查询和设置： .运算符，当属性名为一个简单的标识符时，一个静态值时使用；优先考虑，因为它有更好的可读性； [ ]运算符，该方法更全面，当属性名为变量或动态值时使用；12var name = student.name; var age = student[&quot;age&quot;]; Tips:1、当属性不存在时，会返回 undefined，并不会报错；2、但当查询属性的对象不存在时，则会报错；解决方法：1var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length; 3、可以用 ||运算符来填充默认值；1var sex = student.sex || &quot;unknown&quot;; 7、对象的引用：对象通过引用来传递，他们永远不会被复制。对象并没有被复制，而是仅仅将x,y指向同一个对象的引用而已。1234var x = &#123;a:1&#125;;var y = x;y.a = 2;console.log(x.a); // 2; 8、对象属性的删除：12delete student.name;delete student[&quot;age&quot;]; Tips：delete操作符只能删除自身属性，无法删除原型上的继承属性；delete操作符值是断开属性和宿主对象的联系，并不是删除属性，因此外部的引用仍会存在；12345var a = &#123;x:&#123;y:1&#125;&#125;;var b = a.x;delete a.x;console.log(b); // &#123;y:1&#125;;console.log(a.x); // undefined; 9、检测属性与对象的从属关系： 1、in运算符：12var o =&#123;x:1&#125;;console.log(&quot;y&quot; in o); // false; 2、hasOwnProperty( )：检测是否为自有属性，如果是继承属性，则返回false；123var o = &#123;x:1&#125;;console.log(o.hasOwnProperty(&quot;x&quot;)); // true;console.log(o.hasOwnProperty(&quot;toString&quot;)); // false; 3、propertyIsEnumerable( ): 属于hasOwnProperty的增强版，只有当属性为自有属性且可枚举性时，才返回true;1234var o = &#123;x:1&#125;;console.log(o.propertyIsEnumerable(&quot;x&quot;)); // true;console.log(o.hasOwnProperty(&quot;y&quot;)); // false;console.log(o.hasOwnProperty(&quot;toString&quot;)); // false; 4、直接与undefined比较；123var o = &#123;x:1&#125;;o.x !== undefined; // true;o.y !== undefined; // false; 10、对象属性的getter和setter:在ES5中，对象的属性值可以用一个或两个方法替代，他们就是getter和setter。由这两个方法定义的属性称作“存取器属性”。123456789var serialnum = &#123; &quot;$n&quot;:0, get next()&#123; return this.$n++; &#125;, set next()&#123; if(n&gt;=this.$n)&#123;this.$n = n;&#125;else&#123;throw &quot;新值必须大于当前值。&quot;&#125; &#125;&#125; 11、序列化对象：对象序列化是指将对象的状态转换成字符串，也可以将字符串转换为对象。使用ES5中的 JSON.stringify( ) 和 JSON.parse( )。 1、NaN、Infinity和-Infinity序列化后的结果是Null;2、函数、RegExp、Error对象和undefined值不能序列化和还原；3、JSON.stringify( ) 只能序列化对象可枚举的自有属性； 12、对象方法： 1、toString( )：无需参数，返回一个该对象的字符串。2、toLocaleString( )：返回一个表示这个对象的本地化字符串。3、toJSON( )：4、valueOf( ):","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"Mac终端常用命令","slug":"Mac终端常用命令","date":"2019-11-15T08:21:00.000Z","updated":"2020-01-14T12:52:37.619Z","comments":true,"path":"2019/11/15/Mac终端常用命令/","link":"","permalink":"https://kmbk0.top/2019/11/15/Mac终端常用命令/","excerpt":"","text":"Mac终端常用命令获取系统最高权限 ：sudo -s； 清理系统，也就是执行系统自带的清理脚本：1sudo periodic daily; sudo periodic weekly; 1sudo periodic monthly; 列出文件列表：ls; 切换目录： cd+ 路径; 建立新文件：cd filename; 拷贝文件：cp -R /User/用户名/a /User/用户名/b/; 移动文件：mv -R /User/用户名/a /User/用户名/b/; 删除文件：rm; 更改文件权限：chmod;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"},{"name":"终端","slug":"教程/终端","permalink":"https://kmbk0.top/blog/categories/教程/终端/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://kmbk0.top/blog/tags/Mac/"}]}]}