<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空梦博客-个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kmbk0.top/"/>
  <updated>2020-01-16T05:10:38.061Z</updated>
  <id>https://kmbk0.top/</id>
  
  <author>
    <name>Mr. 空梦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用material-x主题如何自定义添加侧边栏小部件？</title>
    <link href="https://kmbk0.top/2020/01/11/%E4%BD%BF%E7%94%A8material-x%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%B0%8F%E9%83%A8%E4%BB%B6%EF%BC%9F/"/>
    <id>https://kmbk0.top/2020/01/11/使用material-x主题如何自定义添加侧边栏小部件？/</id>
    <published>2020-01-11T10:01:35.000Z</published>
    <updated>2020-01-16T05:10:38.061Z</updated>
    
    <content type="html"><![CDATA[<p>使用material-x主题如何自定义添加侧边栏小部件？ 究竟如何添加？我们来一起看看吧！</p><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>先上Material X主题官网</strong> <a href="https://mxclub.github.io" target="_blank" rel="noopener">戳我进官网 ^_^#&nbsp;</a><br><strong>官方文档</strong> <a href="https://xaoxuu.com/wiki/material-x/index.html" target="_blank" rel="noopener">戳我进官方文档</a><br><strong>官方主题开源网站</strong> <a href="https://github.com/xaoxuu/blog-example" target="_blank" rel="noopener">戳我赢大奖啊ヽ(≧Д≦)ノ</a></p><hr><p><strong><font color="red" size="4">注:我在这里就不多说了，对于如何搭建的想必你也知道怎么搭建。对于不知道如何搭建的朋友请看我前面的文章希望可以帮到你！好了，我也就不废话了。我们开始吧！</font></strong></p><hr><h2 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a><strong>第一步</strong></h3><p>首先我们需要在主题的这个<strong><font color="red">[\themes\material-x\layout_widget]</font></strong>目录下创建你需要的新添加的侧边栏小部件的的名字<strong>xx.ejs&nbsp;</strong> <strong><font color="#FFFF00"> 例如：tq.ejs </font></strong> &nbsp; 如下图</p><p>相应的目录下新建了一个<strong>tq.ejs</strong> 的文件</p><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/1.png" alt=""><br></fancybox><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a><strong>第二步</strong></h3><p>在新建的<strong><code>tq.ejs</code></strong>写入你的自己需要添加的小部件配置代码了，我这里就拿我的侧边栏天气的插件做案例吧！</p><p><strong>以下是代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;section class=&apos;widget &lt;%- item.widget?item.widget:&apos;tq&apos; %&gt;&apos;&gt;</span><br><span class="line">  &lt;%- partial(&apos;header&apos;, &#123;item: item, defIcon: &apos;&apos;, defTitle: &apos;&apos;&#125;) %&gt;</span><br><span class="line">  &lt;div class=&apos;content &lt;%= theme.style %&gt;&apos;&gt;</span><br><span class="line">       &lt;%- markdown(item.body) %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure></p><p><strong>如下图</strong></p><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/2.png" alt=""><br></fancybox><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a><strong>第三步</strong></h3><p>写入代码完成后我们就要去主题文件下的_config.yml文件下配置啦！ 目录<strong><font color="red">[\themes\material-x_config.yml]</font></strong> 这里呢，也是一样的我们需要新建一个<strong><code>widget</code></strong> 这个字段在官网也有教程，我们在这里也就不多说了哈~ (๑乛◡乛๑)  </p><p>以下是代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- widget: tq</span><br><span class="line">  icon: fas fa-cloud</span><br><span class="line">  title: 天气预报</span><br><span class="line">  body: &apos;&lt;iframe name=&quot;weather_inc&quot; src=&quot;https://i.tianqi.com/index.php?c=code&amp;amp;id=7&quot; width=&quot;100%&quot; height=&quot;100&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;padding-left: 10px;&quot;&gt;&lt;/iframe&gt;&apos;</span><br></pre></td></tr></table></figure></p><p><strong>如下图</strong></p><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/3.png" alt=""><br></fancybox><p>这里介绍一下<code>widget</code>以下所用到的字段：</p><ul><li><strong>icon</strong> 小部件的左上角的图标</li><li><strong>title</strong>小部件的名称</li><li><strong>body</strong>小部件所需要的配置文件代码</li></ul><blockquote><p><strong>闲言碎语</strong><br>这里都配置完成后我们就去使用。如何使用呢？这时就要看配置文件里面的说明了！或者看官方文档也是可以的，但是呢有很多人看不懂官方文档主要写的太官方化，这让我们这些小白何以理解啊！嘿嘿！(๑乛◡乛๑)<font size="2" color="#F08080">&nbsp;(小声bb)m(-_-m)～你特喵的还废话~&nbsp;还不赶紧继续写教程。。。。</font> 咳咳，话不多说开干！命苦啊！(ㄒoㄒ)</p></blockquote><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>这一步呢其实挺简单的，也就像是java对象进行调用就行了 <font size="2" color="#F08080">&nbsp; (等会，说什么java啊！写的是hexo博客教程还跑去java了。。.(→_→)一脸嫌弃)</font> 好好，我们言归正传哈！ 这么也就是调用一下刚刚写的那个<code>widget</code>字段配置就行了！这里说一下啊！官方给了我们自由选择的模式添加，例如在主页面的侧边栏添加啊、或者文章页面啊！等等。。这个看自己好吧，看自己需求自由发挥添加，毕竟谁都不想一直跟着别人走啊，总要玩点自己的新花样吧！Σ(ＴωＴ)努力–</p><p><strong>如下图</strong></p><blockquote><p>这里是主题目录下的_config.yml配置</p></blockquote><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/4.png" alt=""><br></fancybox><p>可以看到,这里我添加的两处位置，一个是主页，一个是文章的侧边栏  仔细看图中有红色圈圈的就可以明白了！已经注明很清楚了！</p><blockquote><p><strong>问答</strong><br> <font size="3" color="#FF0000"> 问：有盆友问我，这就完了？这么简单？？？  </font><br>   <strong>答：别着急嘛！最开始我也是这样认为但是呢？其实不是的，这样的话你是无法展示出来的，代码是也不会生效。其实一开始我也是这样认为的，但是在我测试的时候却不是我想的那样。。。咋办捏，这时我们就要去考虑一个问题了，既然是新添加的小部件那我们肯定要去配置哪些小部件是生效的哪些不是，那么问题来了。这个主题配置究竟是不是这样子的呢？谁也说不准那就让我们继续往下看吧！</strong></p></blockquote><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a><strong>第五步</strong></h3><blockquote><p><strong>闲言碎语</strong><br>看到这里我们就要执行最后一步的配置啦！<font size="2" color="#F08080">(是不是很开心！我也要成功啦！其实是废话真tm多，感觉自己像一个 <strong>S*</strong> &nbsp;一样m(-_-m)～)</font>咳咳，让我们言归正传 ，(<font size="2">其实归正几次了，都被我跑遍了！ 好了，不说这些了！</font>) </p></blockquote><p>首先呢这第五步啊！就是要在主题目录的<strong><font color="red">[\themes\material-x\layout_partial]</font></strong> 路径下找到<strong><code>side.ejs</code></strong> <code>side：意思就是侧面、旁边</code>然后进行添加我们自己新建的小部件，这里通俗点说，也就是需要在这里激活你所新建的小部件。<br><strong>如下图</strong></p><blockquote><p>图中所示：找到主题目录文件夹下的<strong><code>side.ejs</code></strong></p></blockquote><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/5.png" alt=""><br></fancybox><blockquote><p>图中所示：添加的新键的<strong><code>tq</code></strong>小部件的调用</p></blockquote><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/6.png" alt=""><br></fancybox><p><strong>好了，这呢。也算是完成了！我们快去试试吧！</strong></p><blockquote><font size="2" color="#F08080">(此时此刻都已经按耐不住我那迫不及待的小心脏了！O(∩_∩)O 想要赶紧去一探究竟啦！)</font></blockquote><p>我们在git 执行以下命令<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure></p><p><strong>好，执行完去看页面看效果！</strong></p><h3 id="最后的效果"><a href="#最后的效果" class="headerlink" title="最后的效果"></a>最后的效果</h3><fancybox><br><img src="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/7.png" alt=""><br></fancybox><p><strong>快看，我们成功了~ 问题是不是解决了？ 哈哈哈！所有的努力没白费！</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p><strong>闲言碎语 </strong><br>好啦，本次教程到此处就已经结束了，此教程呢也是为小白打基础所发布的，再说连小编我也是小白啊！<br>(　＾∀＾)  本是同根生，相煎何太急。<font size="2" color="#F08080">(释义：煮豆来做豆羹，过滤的豆子做成汁。豆杆在锅下燃烧，豆子在锅里哭泣。豆杆和豆子本是从同一条根上生长出来的，为什么要相互煎熬逼迫得那么狠呢？)</font> 虽说油炸起来比较香一些。。。但是…<font size="2" color="#F08080">(你tm 又跑偏了！你在总结，总结。回来)</font>  哈哈！真S* 我们言归正传 <font size="2" color="#F08080">(呃，这个 好像归了好几次了… 算了，三分归元气嘛~ )</font><strong>好，话题结束</strong> </p></blockquote><hr><p><font size="3"><strong>本次总结</strong></font><br>我们在做新建小部件或者插件的时候，需要考虑的问题也就是这个配置到底是不是会自动配置为我们所调用呢？经过我们一番测试来看，我们上面的猜测是对的。这个主题呢~ 官方写的是死的，也就是说必须指定那些已经配置过的小部件然后才能调用和使用，所有呢我们在新建部件的话就要按照这个方法进行配置自行添加自己新建的部件啦！ 好啦，本期文章到此结束啦！<font size="2" color="#F08080">(哎哟，可算结束了，累死我了！又是上传图片、又是打字总结的，嘘！这话不要讲，这么多朋友肯定会给你动力啊！加油！)</font><br>如果您觉得有什么问题可以在下方留言哦！本帖留言已开！ 好了，今天就说这么多，我们下期再见！拜拜！</p>]]></content>
    
    <summary type="html">
    
      使用material-x主题如何自定义添加侧边栏小部件？ 究竟如何添加？我们来一起看看吧！
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="https://kmbk0.top/blog/tags/Hexo/"/>
    
      <category term="主题优化" scheme="https://kmbk0.top/blog/tags/%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    
      <category term="配置" scheme="https://kmbk0.top/blog/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Markdown简明语法</title>
    <link href="https://kmbk0.top/2020/01/06/Markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/"/>
    <id>https://kmbk0.top/2020/01/06/Markdown简明语法/</id>
    <published>2020-01-06T00:35:56.000Z</published>
    <updated>2020-01-14T12:52:59.836Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>#Markdown简明语法</p><blockquote><p>Markdown是一种可以让人专注于内容与代码的轻量级的【标记语言】。让我们离开那些繁琐的排版与样式，专注于内容吧！！！</p></blockquote><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在Markdown中，标题是使用 1-6个<code>#</code> 进行标记，分为六级：<code>#</code> 、<code>##</code>、<code>###</code>……  ，刚好对应h1~h6:</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h3 id="区块与段落"><a href="#区块与段落" class="headerlink" title="区块与段落"></a>区块与段落</h3><p>区块则是使用 <code>&gt;</code> 来进行标记：</p><blockquote><p>这是一个区块啊！！！！</p></blockquote><p>可以通过首尾个空一行来形成一个段落，也就是类似于在HTML中以 <code>&lt;p&gt;</code>标签包起来：（注：官方语法推荐在标记的后面加入一个空格）</p><p>这是一个段落啊！我被<code>&lt;p&gt;</code>包住啦！</p><h3 id="有序列表与无序列表"><a href="#有序列表与无序列表" class="headerlink" title="有序列表与无序列表"></a>有序列表与无序列表</h3><p>学过HTML的同学一定知道 <code>&lt;li&gt;和&lt;ol&gt;</code>,而在MD中，无序列表可以用 <code>*/+/-</code>来进行标注：（通过行首加入tab，可标记二级列表）</p><blockquote><ul><li>小米</li></ul><ul><li>华为</li></ul><ul><li>苹果<ul><li>oppo</li><li>vivo</li></ul></li></ul></blockquote><p>而有序列表则直接使用数字进行标记：</p><blockquote><ol><li>品牌</li><li>电器</li><li>物品</li></ol></blockquote><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>输出为HTML中的 <code>&lt;strong&gt;\&lt;em&gt;</code>，使用 <code>*</code>和<code>**</code>包住强调的部分：</p><blockquote><p>你好！我是一个 <em>强调</em> 哦！！<br>你好！我是一个比你还厉害的二级 <strong>强调</strong> 哦！</p></blockquote><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>输出为HTML中的 <code>&lt;a&gt;</code>标签，使用 <code>[]</code>直接包裹链接部分，后直接跟上<code>()</code>填入链接到的地址（也可以在地址后面 空格+title）：</p><blockquote><p>你好！我叫度娘 <a href="www.baidu.com" title="这里是title哦！">戳我一下去我家啊</a>；</p></blockquote><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>输出为HTML中的 <code>&lt;img&gt;</code>标签，用法与标记链接基本一致：</p><blockquote><p>我是一张图片](<a href="https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/17.jpg&quot;Title&quot;)；" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/17.jpg&quot;Title&quot;)；</a></p></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>当你需要在文章中添加代码时，比如 <code>&lt;p&gt;hello world&lt;/p&gt;</code> ，如果直接输入，则会变成   </p><blockquote><p>hello world</p> </blockquote><p>p标签被直接翻译吃掉啦！因此，我们需要对代码块进行特殊的标识：</p><ul><li><p>行内代码块： 使用反引号进行包裹：    </p><blockquote><p><code>&lt;p&gt;hello world&lt;/p&gt;</code></p></blockquote></li><li><p>块状代码块：使用tab对整体代码进行缩进；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>MD的表格有点好玩，其实就是使用 <code>|</code>画出一个表格来，但其实这有点小麻烦：</p><blockquote><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:right">Value</th><th style="text-align:center">Qty</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 USD</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 USD</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 USD</td><td style="text-align:center">234</td></tr></tbody></table></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>熟练的使用上述的这些规则，应该就能应付平时的日常使用了，除了表格比较麻烦外，其它都简单易用。但需要多多联系，熟能生巧嘛。~在日后写博客的过程中，慢慢的掌握它！加油哦~~~</p>]]></content>
    
    <summary type="html">
    
      Markdown简明语法
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Markdown" scheme="https://kmbk0.top/blog/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Sass基础用法</title>
    <link href="https://kmbk0.top/2020/01/01/Sass%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>https://kmbk0.top/2020/01/01/Sass基础用法/</id>
    <published>2020-01-01T01:25:00.000Z</published>
    <updated>2020-01-14T12:53:44.179Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>#Sass基础用法</p><h3 id="1、变量："><a href="#1、变量：" class="headerlink" title="1、变量："></a>1、变量：</h3><p>Sass中的变量需要以 <code>$</code>开头进行命名，如 <code>$blue</code>;如果需要插入在字符串中，则需使用<code>#{ }</code>进行包裹；如：<code>border-#{$de}-color</code>;</p><h3 id="2、计算："><a href="#2、计算：" class="headerlink" title="2、计算："></a>2、计算：</h3><p>Sass允许在语句中直接使用算式记性计算，如：<code>right: $var * 10;</code></p><h3 id="3、嵌套："><a href="#3、嵌套：" class="headerlink" title="3、嵌套："></a>3、嵌套：</h3><p>Sass可以使用语法的嵌套，可以使代码的可读性更强。如：</p><p>(1) 标签嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">h1&#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)属性嵌套：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">border:&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>TIPS：<br>在嵌套的代码中，可以使用<code>&amp;</code>来引用父级，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">&amp;:hover&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="4、注释："><a href="#4、注释：" class="headerlink" title="4、注释："></a>4、注释：</h3><p><code>/* 注释 */</code>：普通注释，会保留到编译后的文件中，如果使用压缩模式编译，则会省略；</p><p><code>// 注释</code>：只保留在Sass源文件中，编译后则省略；</p><p><code>/*! 重要注释 */</code>：压缩模式下编译也会保留；</p><h3 id="5、继承："><a href="#5、继承：" class="headerlink" title="5、继承："></a>5、继承：</h3><p>使用 <code>@extend</code> 可实现继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.class1&#123; &#125;;</span><br><span class="line">.class2&#123;</span><br><span class="line">@extend class1;</span><br><span class="line">font-size:14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6、重用代码块："><a href="#6、重用代码块：" class="headerlink" title="6、重用代码块："></a>6、重用代码块：</h3><p>使用 <code>@mixin</code>进行代码块的定义，使用<code>@include</code>进行已定义的代码块的调用；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@mixin left&#123;</span><br><span class="line">float:left;</span><br><span class="line">margin-left:10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line">@include left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在代码块的定义中，也可以传入参数和默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@mixin left($value:10px)&#123;</span><br><span class="line">float:left；</span><br><span class="line">margin-right:$value;</span><br><span class="line">&#125;</span><br><span class="line">// 调用；</span><br><span class="line">div&#123;</span><br><span class="line">@include left(20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7、插入文件："><a href="#7、插入文件：" class="headerlink" title="7、插入文件："></a>7、插入文件：</h3><p>可以使用 <code>@import</code>进行文件的引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;path/filename.scss&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="8、条件判断："><a href="#8、条件判断：" class="headerlink" title="8、条件判断："></a>8、条件判断：</h3><p>使用 <code>@if/@else</code>写条件语句；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">@if 1+1 == 2&#123;</span><br><span class="line">width:10px;</span><br><span class="line">&#125;@else&#123;</span><br><span class="line">width:20px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="9、循环语句："><a href="#9、循环语句：" class="headerlink" title="9、循环语句："></a>9、循环语句：</h3><p>for循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@for $i from 1 to 10&#123;</span><br><span class="line">.border-#&#123;$i&#125;&#123;</span><br><span class="line">border:#&#123;$i&#125;px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>while循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$i:6;</span><br><span class="line">@while $i&gt;0&#123;</span><br><span class="line">.item-#&#123;$i&#125;&#123;</span><br><span class="line">width:2em * $i;</span><br><span class="line">&#125;</span><br><span class="line">$i:$i-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>each语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@each $menber in a,b,c,d&#123;</span><br><span class="line">.#&#123;$menber&#125;&#123;</span><br><span class="line">background:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="10、自定义函数："><a href="#10、自定义函数：" class="headerlink" title="10、自定义函数："></a>10、自定义函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double($n)&#123;</span><br><span class="line">@return $n * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar&#123;</span><br><span class="line">width:double(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Sass基础用法
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Sass" scheme="https://kmbk0.top/blog/tags/Sass/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言编程核心（四）--- 函数（待完成）</title>
    <link href="https://kmbk0.top/2019/12/16/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83(%E5%9B%9B)%E2%80%94%E5%87%BD%E6%95%B0(%E5%BE%85%E5%AE%8C%E6%88%90)/"/>
    <id>https://kmbk0.top/2019/12/16/JavaScript语言编程核心(四)—函数(待完成)/</id>
    <published>2019-12-16T05:21:00.000Z</published>
    <updated>2020-01-14T12:52:29.761Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="JavaScript语言编程核心（四）—-函数（待完成）"><a href="#JavaScript语言编程核心（四）—-函数（待完成）" class="headerlink" title="JavaScript语言编程核心（四）— 函数（待完成）"></a>JavaScript语言编程核心（四）— 函数（待完成）</h2><p>在编程过程中，我们很经常会需要多次使用到一段代码，此时便需要把这段代码定义成函数，从而可以调用任意次。</p><p>函数是JavaScript中最出色的设计之一，它们是JS中基础模块单元，可用于代码复用，信息隐藏和组合调用。JS中的函数就是对象，也拥有自己的方法，它连接到Function.prototype上。</p><p>本文参考《JavaScript权威指南》；</p><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>一般有两种方式可以创建函数：函数声明与函数表达式；</p><p><strong>函数声明：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这种形式的声明会被提前到作用域的顶部，所以可以在被定义之前调用它，称为 <strong>声明提前</strong>；</p></blockquote><p><strong>函数表达式：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add = function(a,b)&#123;</span><br><span class="line">return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>表达式的形式并不能在定义之前调用它，虽然<code>var add</code>也会被提前到作用域顶部，但赋值语句并不会被执行，此时<code>add</code>扔为<code>undefined</code>，所以只有在表达式定以后，才能进行函数的调用。</p></blockquote><h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><p>1、函数声明可以出现在全局代码中，也可以被嵌套在其它函数内，但根据规定，不能出现在循环，判断，try/catch/finally与with语句中。而函数表达式可以出现在任何地方。</p><p>2、定义在其它函数内部的函数，包含一个连接到外部上下文的连接[[scope]]，可以自由访问它的父函数中的参数与变量，这便是JS中的 <strong>闭包</strong>。</p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>调用一个已经定义好的函数有4种方式，会传入 实参，this, arguments。</p><h4 id="1、函数调用模式"><a href="#1、函数调用模式" class="headerlink" title="1、函数调用模式"></a>1、函数调用模式</h4><p>可以直接在函数名称的后面加上<code>()</code>，传入参数完成函数的调用，如<code>add(3,4)</code>；此时，根据ES5或者ES5非严格模式，调用上下文( this )被指向全局对象；而在ES5严格模式中，this 则为 <code>undefined</code>；</p><blockquote><p>因此可以这样来检测是否为严格模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var strict = (function()&#123;return !this;&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="2、方法调用模式"><a href="#2、方法调用模式" class="headerlink" title="2、方法调用模式"></a>2、方法调用模式</h4><p>当一个函数被保存成一个对象的属性时，则成为一个方法，此时 this 指向保存该函数的对象。如 <code>object.method()</code>；</p><p>多数情况下，可以直接用 <code>.</code>符号来直接访问，但少数情况下可能需要使用<code>[ ]</code>来进行属性的访问操作。</p><blockquote><p><strong>方法链</strong><br>也称为 <strong>链式调用</strong>或<strong>级联调用</strong>，我们可以在一个方法中返回一个对象，从而可以继续调用它的方法。如JQuery中就是这么实现的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.header&quot;).map().get().sort();</span><br></pre></td></tr></table></figure></p></blockquote><p>这将使代码变得更为简洁和易读，因此当方法不需要返回值时，最好直接返回this。</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>this是函数中的一个关键字 ，它指向函数的调用上下文，并不是变量，也不是属性名，因此不能对其进行赋值。</p><p>如果作为方法调用函数，则this指向保存该方法的对象；</p><p>如果在函数调用中，this可能指向全局或者<code>undefined</code>，因此，在闭包中，如果想访问父级的this，则通常是将this保存在一个变量里，便可以通过作用域链进行访问，一般可以命名为 self/that/me。</p><h4 id="this总结："><a href="#this总结：" class="headerlink" title="this总结："></a>this总结：</h4><blockquote><p>1、全局环境中，则指向 <strong>全局对象（windows）</strong>。</p><p>2、构造函数里的this，则指向 <strong>新创建的对象</strong>；</p><p>3、函数中的this，指向 <strong>函数的调用者</strong>；</p><p>4、new Function，指向 <strong>全局对象（windows）</strong>;</p><p>5、eval中，指向<strong>调用上下文中的this</strong>；</p></blockquote><h4 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h4><p>如果函数或者方法调用之前带有关键字 <code>new</code>，它就构成构造函数式调用。构造函数的处理方式跟普通的调用在实参处理、调用上下文和返回值方面都有着不同。</p><blockquote><p>1、当构造函数没有形参时，可以省略实参列表和圆括号；</p><p>2、<code>new</code>操作符的操作步骤可以分成3步：</p><p>（1）创建一个新对象；</p><p>（2）新对象继承构造函数的<code>prototype</code>属性，this指向该新对象，也就是说，就算即使使用<code>new o.m()</code>，函数中的<code>this</code>值也是指向新对象，而不是<code>o</code>；</p><p>（3）执行函数语句，为新对象添加属性，方法；</p><p>（4）返回该新对象；通常，构造函数中不适用<code>return</code>，但如果有主动<code>return</code>一个对象，则返回该对象；如果没有返回或者返回一个原始值，则返回最初创建的对象；</p></blockquote><h4 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h4><p>使用<code>call()</code>和<code>apply()</code>可以间接地调用函数，它们可以显式地指定this值，也就是说，任何函数都可以作为任何对象的方法来调用。</p><p><code>call(this,p1,p2,p3)</code>：以自己的实参列表作为传入函数的实参；<br><code>apply(this,[p1,p2,p3])</code>：以数组的形式传入实参；</p><h3 id="函数的实参与形参"><a href="#函数的实参与形参" class="headerlink" title="函数的实参与形参"></a>函数的实参与形参</h3><h4 id="1、实参数量少于形参"><a href="#1、实参数量少于形参" class="headerlink" title="1、实参数量少于形参"></a>1、实参数量少于形参</h4><p>调用函数时，当实参的数量少于定义的形参时，则后面的形参的值均为<code>undefined</code>。因此，在设置形参的时候，理想的情况是为参数设置一个合理的默认值，可以使用下面的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a || 0;  // 形参设置为 a</span><br></pre></td></tr></table></figure></p><p>但传入的实参和形参只是以顺序的位置对应，并无法主动地为他们指定关系，也就是说，无法省略第一个实参，而直接传入第二个实参，必须填入占位的<code>undefined</code>或者<code>null</code>，因此可选的形参只能放在是参列表的最后。推荐对可选参数进行清晰的注释。</p><h4 id="2、实参数量多于形参"><a href="#2、实参数量多于形参" class="headerlink" title="2、实参数量多于形参"></a>2、实参数量多于形参</h4><p>调用函数式，当实参的数量大于定义的形参时，可以通过参数对象来获取超过部分的实参。这个对象称为 <code>arguments</code>，是一个类数组，包含着传入的所有实参列表，它可以通过类似于数组的<code>[0]</code>,<code>[1]</code>进行索引，访问传入的实参。同时，它还拥有可以<code>length</code>的属性，可以获取到传入函数的实参数量。</p><p>该对象有一个重要的用处，既让函数可以处理不定数量的实参，这种函数也成为 <strong>不定实参函数（varargs function）</strong>。比如，求任意个数字的总和，便可以定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var add = function()&#123;</span><br><span class="line">var sum = 0,</span><br><span class="line">i;</span><br><span class="line">l = arguments.length;</span><br><span class="line">// 遍历实参对象，累加每一个实参；</span><br><span class="line">for(i=0;i&lt;l;i++)&#123;</span><br><span class="line">sum += arguments[i];</span><br><span class="line">&#125;</span><br><span class="line">// 返回结果；</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sum = add(1,2,3,4,5);     // sum为15；</span><br></pre></td></tr></table></figure></p><blockquote><p>Tips:<br>1、实参对象arguments其实是实参的一个指针数组，并不是一个真正的数组，也就是说，上面函数中，<code>arguments[0] === 1</code>的值为 <code>true</code>。在非严格模式下，可以通过实参对象来修改传入函数的实参的值。</p></blockquote><blockquote><p>2、实参对象还包含两个值，<code>callee</code>和<code>caller</code>。在严格模式下，不能对这两个值进行读写操作，但在非严格模式下，<code>callee</code>指向当前函数本身，<code>caller</code>则指向调用函数的函数。</p></blockquote><blockquote><p>3、记住定义的形参顺序，是个麻烦的事，因此可以使用直接传入对象，对象中是一个所有参数的键值对集合。</p></blockquote><blockquote><p>4、合理的实参类型检测，是避免函数执行错误的保证。</p></blockquote><h4 id="自定义函数属性"><a href="#自定义函数属性" class="headerlink" title="自定义函数属性"></a>自定义函数属性</h4><p>由于函数的本质也是一个特殊的对象，它也可以拥有自己的属性。当有些函数需要一些静态的值时，其实可以将其保存在函数的自身属性中，从而避免保存到全局环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function integer()&#123;</span><br><span class="line">return integer.counter++;</span><br><span class="line">&#125;</span><br><span class="line">integer.counter = 0;</span><br><span class="line">// 点击一次，计时器累加1；</span><br><span class="line">$(document).on(&quot;click&quot;,function()&#123;</span><br><span class="line">console.log(integer());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="作为命名空间的函数"><a href="#作为命名空间的函数" class="headerlink" title="作为命名空间的函数"></a>作为命名空间的函数</h4><p>一般，我们会避免在全局环境中添加变量，避免污染全局的命名空间，一个很好的解决方法，便是将代码放置于一个函数作用域内。一般使用匿名的立即执行函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">// 模块代码;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      JavaScript语言编程核心（四）--- 函数（待完成）
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kmbk0.top/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言编程核心（三）--- 执行上下文与作用域</title>
    <link href="https://kmbk0.top/2019/12/05/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83(%E4%B8%89)%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://kmbk0.top/2019/12/05/JavaScript语言编程核心(三)—执行上下文与作用域/</id>
    <published>2019-12-05T00:21:00.000Z</published>
    <updated>2020-01-14T12:51:00.278Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="JavaScript语言编程核心（三）—-执行上下文与作用域"><a href="#JavaScript语言编程核心（三）—-执行上下文与作用域" class="headerlink" title="JavaScript语言编程核心（三）— 执行上下文与作用域"></a>JavaScript语言编程核心（三）— 执行上下文与作用域</h1><h3 id="执行上下文（EC）"><a href="#执行上下文（EC）" class="headerlink" title="执行上下文（EC）"></a>执行上下文（EC）</h3><p><strong>执行上下文</strong>：可以抽象为一个简单的对象，在一个函数或者eval( )被执行时创建，对象里面包含着一些代码运行所需的属性，统称为 <strong>上下文状态</strong>。一个上下文状态由三个结构组成：</p><ul><li>变量对象(variable Object);</li><li>作用域链(scope chain)；</li><li>this指向(thisValue)；</li></ul><h3 id="执行上下文堆栈"><a href="#执行上下文堆栈" class="headerlink" title="执行上下文堆栈"></a>执行上下文堆栈</h3><p>一般可以认为有三种执行上下文：</p><ul><li>全局执行上下文；</li><li>函数执行上下文；</li><li>eval执行上下文；</li></ul><p>一个执行上下文可以触发另一个上下文，以栈的形式实现，称为执行上<strong>下文堆栈</strong>。</p><p>触发其它上下文的叫做 <code>caller</code>，而被触发的上下文叫做 <code>callee</code>；</p><blockquote><p>1.当代码执行的时候，首先生成一个全局执行上下文（<code>global EC</code>）。</p></blockquote><blockquote><p>2.当执行到函数作用域时，全局执行上下文（<code>caller</code>）会触发该函数执行上下文(<code>callee</code>)，将控制权传递给<code>callee</code>，而此时<code>caller</code>则暂缓执行。<code>callee</code>被push到栈的最顶层，拥有控制权，成为当前运行的执行上下文(<code>active EC</code>)。</p></blockquote><blockquote><p>3.当<code>callee</code>执行结束后，控制权会返还给<code>caller</code>，<code>callee</code>从栈顶层被pop除，<code>caller</code>继续往下执行。</p></blockquote><h3 id="变量对象-VO"><a href="#变量对象-VO" class="headerlink" title="变量对象(VO)"></a>变量对象(VO)</h3><p><strong>变量对象</strong>是执行上下文中的一个数据作用域，存储着上下文中所定义的变量和函数声明（不包括函数表达式）。</p><blockquote><p>全局上下文的变量对象就全局对象本身。</p></blockquote><h3 id="活动对象（AO）"><a href="#活动对象（AO）" class="headerlink" title="活动对象（AO）"></a>活动对象（AO）</h3><p>当函数被<code>caller</code>触发时，该函数的变量对象（VO）则会被激活成为活动对象（AO），里面加入了形参和arguments对象。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>作用域</strong>：通俗点可以理解为是一段代码或者一个变量的作用范围，是程序源代码中定义这个变量的区域，可以简单的理解为一个对象，其实，变量对象便是作用域的实体。比如，一个全局变量，就拥有全局的作用域，在JavaScript代码的所有地方都有定义，都可以进行访问，理解为一个全局对象中定义着这个全局属性。</p><p>在许多编程语言中，每个花括号中的代码都具有各自的作用域，而在花括号的外部，是不可见的，这称为 <strong>块级作用域(block scope)</strong>。但在JavaScript中，虽然语法上也是使用花括号，但并不存在块级作用域，在花括号内定义的变量，在外部都是可见的。取而代之的是<strong>函数作用域(function scope)</strong>：在一个函数中声明的变量，在该函数，包括其内部嵌套函数中，都是有定义，可见的。但在函数的外部是不可见的。</p><blockquote><p>因此，这里就引出了另一个概念– <strong>声明提前</strong>。<br>根据函数作用域的定义，一个声明在函数体内的任何地方都是始终可见的，甚至在声明之前。因此，就算在声明一个变量之前，也是可以访问到这个变量的（但不涉及到赋值）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global&quot;;</span><br><span class="line">(function()&#123;</span><br><span class="line">// 并不是输出global，这是因为声明提前，等于在该语句前加了一句，var scope。但并不涉及赋值；</span><br><span class="line">console.log(scope);      // undefined；</span><br><span class="line">var scope = &quot;local&quot;;</span><br><span class="line">console.log(scope); // local;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在定义一个函数作用域时，会随之产生一个与之关联的<strong>作用域链(scope chain)</strong>。这个作用域链是一个对象列表，列表内包含所有父级变量对象和自身的活动对象，另外，通过<code>with语句</code>和<code>catch语句</code>也可动态的延长作用域链。</p><blockquote><p>作用域链其实是由两部分组成的：函数内部属性 <code>[[scope]]</code>  + 自身活动对象(<code>AO</code>)；<br>在<code>[[scope]]</code>属性中，保存着父级函数的作用域链。</p></blockquote><p>当在函数内访问一个变量时，首先会从该函数自身的活动对象中查找，如果不存在，则会沿着作用域链往上一级一级查找父级变量对象。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>由于在JavaScript中，函数属于第一级对象，即可以当成参数传入一个函数，也可以从函数中返回出一个函数。此时，便会出现一个问题，当一个父函数执行后返回另一个子函数后，便会被摧毁，而此时，返回的子元素的[[scope]]属性中仍然保存着父函数的作用域链，以此来解决访问父函数中变量的问题。</p><p>这种类型的作用域，成为静态（词法）作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var afun = (function()&#123;</span><br><span class="line">var a = 1;</span><br><span class="line">return function afun()&#123;</span><br><span class="line">alert(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var a = 2;</span><br><span class="line">afun();      // 1</span><br></pre></td></tr></table></figure></p><p> 静态作用域是闭包存在的一个必需条件，因此 </p><blockquote><p><strong>闭包</strong>可以定义为：</p></blockquote><blockquote><p>一个函数，和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。</p></blockquote><blockquote><p>Tips：从理论上讲，每一个函数都可以称为闭包，因为都包含了<code>[[scopte]]</code>属性。</p></blockquote><p>当在一个父函数中定义了两个子函数时，此时两个子函数拥有相同的[[scope]]属性，而且是共享的。也就是说，改变一个闭包中的变量，会影响到另一个闭包中的变量。这也就是我们最常见的闭包问题的根源所在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for(var i = 0;i&lt;10;i++)&#123;</span><br><span class="line">a[i] = function()&#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 而不是预期中的 0~9，其原因就是这9个函数共享一样的[[scope]]属性；</span><br><span class="line">a[0]();   // 10;</span><br><span class="line">a[1]();   // 10;</span><br><span class="line">a[9]();   // 10;</span><br></pre></td></tr></table></figure></p><p>可以通过将参数<code>i</code>以参数的形式传入，让其不需要从<code>[[scope]]</code>属性中进行查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for(var i = 0;i&lt;10;i++)&#123;</span><br><span class="line">a[i] = (function(x)&#123;</span><br><span class="line">return function()&#123;</span><br><span class="line">console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">a[0]();   // 0;</span><br><span class="line">a[1]();   // 1;</span><br><span class="line">a[9]();   // 9;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      JavaScript语言编程核心（三）--- 执行上下文与作用域
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kmbk0.top/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言编程核心（二）--- 代码的复用模式</title>
    <link href="https://kmbk0.top/2019/12/03/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83(%E4%BA%8C)%E2%80%94%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kmbk0.top/2019/12/03/JavaScript语言编程核心(二)—代码的复用模式/</id>
    <published>2019-12-03T04:01:00.000Z</published>
    <updated>2020-01-14T12:51:58.154Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="JavaScript语言编程核心（二）—-代码的复用模式"><a href="#JavaScript语言编程核心（二）—-代码的复用模式" class="headerlink" title="JavaScript语言编程核心（二）— 代码的复用模式"></a>JavaScript语言编程核心（二）— 代码的复用模式</h1><p>在大多数编程语言中，代码复用都是很重要的一块内容，而代码的继承性，是代码复用的一种重要形式，可以显著地减少开发成本，提高开发效率。继承的方式可以大致的分成两类：1、传统的类式继承；2、现代化继承方式：包括原型继承、复制属性继承、混入、借用、借用与绑定。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在JavaScript中，构造函数其实也是一类普通函数，但它有几个特点：</p><blockquote><p>1、函数名首字母大写，以区分普通函数；<br>2、通过this创建新的属性和方法；<br>3、配合new操作符，可创建出一个新对象；</p></blockquote><h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><p>new操作可以配合函数，返回一个对象，实际上它是做了三件事情：</p><blockquote><p>1、创建一个新对象； <code>var _obj = {}</code>；<br>2、使<code>_obj</code>继承该函数的原型；<code>obj.__proto__ = CO.prototype</code>;<br>3、执行函数中的语句，为this指向添加属性、方法；<br>4、返回该新对象；</p><p><strong>Tips：</strong><br>如果函数中有主动return一个对象，则返回该对象，否则隐式返回<code>_obj</code>;<br>如果忘记使用new，则会造成在全局中添加属性和方法，这是很糟糕的。因此不要忘记new！<br>为了避免当忘记new时，不会出现意外，便出现了一种模式，称为 <strong>自调用构造函数</strong>，它可以使得  <code>var a = new CO()</code>与<code>var a = CO()</code>效果一致；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">if(!(this instanceof Person))&#123;</span><br><span class="line">return new Person();</span><br><span class="line">&#125;</span><br><span class="line">this.name = &quot;dong&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><p>实现类式继承的目标，是通过构造函数Child( )来获取一个父类构造函数Parent( )的属性，然后再由new Child( )实例化对象，实现继承。因此，关键的步骤就是 <code>inherit(Child,Parent)</code>;</p><p>这里，有多种模式可以完成这样的继承函数：</p><h3 id="1、默认模式："><a href="#1、默认模式：" class="headerlink" title="1、默认模式："></a>1、默认模式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function inherit(c,p)&#123;</span><br><span class="line">c.prototype = new P();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:<br>对象指向原型，使用对象内部的<code>__proto__</code>属性，指向一个实例对象。但该属性不符合W3C标准，不能使用，但可以让我们更好的理解JS的原型继承的概念；<br>构造函数指向原型，使用<code>prototype</code>属性，也是指向一个实例对象；<br>通过默认模式完成的继承，属性与方法并不在自身上，只是通过原型链查找到的，仅仅是获取到引用，而且无法通过子构造函数传参。</p></blockquote><h3 id="2、借用构造函数："><a href="#2、借用构造函数：" class="headerlink" title="2、借用构造函数："></a>2、借用构造函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Child(a,b,c,d)&#123;</span><br><span class="line">Parent.apply(this,arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是只可以继承父级构造函数中添加到this的属性，原型中的属性并不能继承。但相比于第一种默认方式，它继承的属性都变成了自身属性，即hasOwnProperty为true，而不是从原型链上查找到的属性。</p><blockquote><p>通过该模式，可以实现多重继承，即同时继承多个父级函数的属性；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Child()&#123;</span><br><span class="line">Father.apply(this,arguments);</span><br><span class="line">Mother.apply(this,arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>该模式的优点是，继承后的子级是父级函数的真实副本，操作子级函数并不会影响或覆盖父级函数。<br>而缺点，便是无法从原型中继承属性，而是为每个实例都初始化各自的方法属性。</p></blockquote><h3 id="借用与设置原型"><a href="#借用与设置原型" class="headerlink" title="借用与设置原型"></a>借用与设置原型</h3><p>为了解决借用模式的缺点，我们可以为其设置原型来解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Child()&#123;</span><br><span class="line">Parent.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Person();</span><br></pre></td></tr></table></figure></p><p>这样既能得到父级函数中属性的真是副本，又可以继承到原型上的方法。但仍然是有缺点，便是该模式调用了两次<code>Parent</code>构造函数，属性被继承了两次，导致了效率的低下。</p><h3 id="共享原型"><a href="#共享原型" class="headerlink" title="共享原型"></a>共享原型</h3><p>该模式有点类似于第一种默认方式，但是不同点在于，将子函数的原型直接指向父级构造函数的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function inherit(c,p)&#123;</span><br><span class="line">c.prototype = p.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要将要复用的属性，方法都放在父级的原型里，即可以达到继承的目的。但是该模式的缺点在于，当修改了继承的子级的原型时，便直接影响到了该类中的所有对象。</p><h3 id="代理构造函数模式"><a href="#代理构造函数模式" class="headerlink" title="代理构造函数模式"></a>代理构造函数模式</h3><p>通过创建一个代理构造函数，链接父级函数的原型与子级函数，从而避免了共享原型所带来的弊端，而且可以利用原型链的优势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function inherit(c,p)&#123;</span><br><span class="line">var F = function()&#123;&#125;;</span><br><span class="line">F.prototype = p.prototype;</span><br><span class="line">c.prototype = new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Tips：</strong><br>该模式不会继承父级构造函数上this的属性，只会继承父级原型上的属性。<br>更近一步，可以将父级构造函数和其原型的存为子级构造函数的一个指针，以备不时之需；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.uber = p.prototype;</span><br><span class="line">c.prototype.constructor = c;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="综上可以整理出最后，也是JS中较为完美的类式继承模式，也称为-圣杯模式；"><a href="#综上可以整理出最后，也是JS中较为完美的类式继承模式，也称为-圣杯模式；" class="headerlink" title="综上可以整理出最后，也是JS中较为完美的类式继承模式，也称为 圣杯模式；"></a>综上可以整理出最后，也是JS中较为完美的类式继承模式，也称为 圣杯模式；</h3><p>最后一点优化，便是使用即时执行函数和闭包，优化每次都需要创建一个新的代理函数的缺点。</p><h3 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inherit = (function(c,p)&#123;</span><br><span class="line">var F = function()&#123;&#125;;</span><br><span class="line">return function(c,p)&#123;</span><br><span class="line">F.prototype = p.prototype;</span><br><span class="line">c.prototype = new F();</span><br><span class="line">c.uber = p.prototype;</span><br><span class="line">c.prototype.constructor = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Klass语法糖"><a href="#Klass语法糖" class="headerlink" title="Klass语法糖"></a>Klass语法糖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var klass = function(Parent,props)&#123;</span><br><span class="line">var Child,F,i;</span><br><span class="line">// 1.</span><br><span class="line">// 新构造函数；</span><br><span class="line">Child = function()&#123;</span><br><span class="line">if(Child.uber &amp;&amp; Child.uber.hasOwnProperty(&quot;__construct&quot;))&#123;</span><br><span class="line">Child.uber.__construct.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">if(Child.prototype.hasOwnProperty(&quot;__construct&quot;))&#123;</span><br><span class="line">Child.prototype.__construct.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.</span><br><span class="line">// 继承;</span><br><span class="line">Parent = Parent || Object;</span><br><span class="line">F = function()&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = new F();</span><br><span class="line">Child.uber = Parent.prototype;</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">// 3.</span><br><span class="line">// 添加实现方法：</span><br><span class="line">for(i in props)&#123;</span><br><span class="line">if(props.hasOwnProperty(i))&#123;</span><br><span class="line">Child.prototype[i] = props[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4.</span><br><span class="line">// 返回该Child;</span><br><span class="line">return Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="现代化继承方式"><a href="#现代化继承方式" class="headerlink" title="现代化继承方式"></a>现代化继承方式</h2><h3 id="1、原型继承："><a href="#1、原型继承：" class="headerlink" title="1、原型继承："></a>1、原型继承：</h3><p>对象可以通过为它指定原型对象而完成继承，这样的继承称为<strong>委托继承</strong>，也可以称为<strong>原型继承</strong>。原型对象也是一个简单的对象，此时也可以继续为它指定它的原型对象而完成继承。此时，由 实例对象 —&gt; 原型对象 —&gt; 原型对象…，这样构建出来的一条线，便称为原型链。</p><blockquote><p><strong>原型链</strong>：是由原型对象组成，是一个用来实现继承和共享属性的有限的对象链。</p></blockquote><blockquote><p><strong>属性查找机制</strong>：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；</p></blockquote><blockquote><p><strong>属性修改机制</strong>：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用：<code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</p></blockquote><p>1、通过<code>__proto__</code>来实现原型继承，从测试代码可以看出，b对象继承了a对象的x属性，同时a对象继承于顶级的原型对象 Object.prototype。因此则组成了一条原型链：   b —&gt;  a —&gt; Object.prototype;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">var a = &#123;x:1&#125;;</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line">b.__proto__ = a;</span><br><span class="line">console.log(b.x);   // 1；</span><br><span class="line">console.log(a.__proto__ == Object.prototype);   // true;</span><br><span class="line">console.log(b.__proto__ == Object.prototype);   // false;</span><br></pre></td></tr></table></figure></p><p>2、第二种方式可以使用ES5中的Object.create( )方法来实现原型的继承：<br>也就是可以通过给一个函数F，直接通过<code>prototype</code>指定一个实例对象作为原型，完成继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 低版本浏览器的兼容；</span><br><span class="line">if(!Object.create)&#123;</span><br><span class="line">Object.create = function(o)&#123;</span><br><span class="line">if(arguments.length&gt;1)&#123;</span><br><span class="line">throw new Error(&quot;只接受第一个参数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function F()&#123;&#125;;   // 创建一个新对象；</span><br><span class="line">F.prototype = o;   // 将新对象的原型对象指向传入对象；</span><br><span class="line">return new F();   // 返回该对象的实例； </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、通过复制属性实现继承"><a href="#2、通过复制属性实现继承" class="headerlink" title="2、通过复制属性实现继承"></a>2、通过复制属性实现继承</h3><p>这种模式中，对象将从另一个对象中以直接复制的形式继承属性，可以由一个extend( )实现复制继承。</p><p><strong>浅复制</strong>：如果对象中的属性是对象，那只是简单的进行引用的复制。会导致修改子对象的对象属性，则父对象的属性也会被修改；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function extend(parent,child)&#123;</span><br><span class="line">var i;</span><br><span class="line">child = child || &#123;&#125;;</span><br><span class="line">// 遍历父对象的属性，判断是否为自身属性；</span><br><span class="line">for(i in parent)&#123;</span><br><span class="line">if(parent.hasOwnProperty(i))&#123;</span><br><span class="line">child[i] = parent[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>深复制</strong>：以浅复制的形式，增加判断，当遇到属性是对象时，则递归进行更深一步的复制；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function extendDeep(parent,child)&#123;</span><br><span class="line">var i,</span><br><span class="line">toStr = Object.prototype.toString;</span><br><span class="line">child = child || &#123;&#125;;</span><br><span class="line">// 遍历父对象属性，先判断是否为自身属性，后属性值判断是否为对象；</span><br><span class="line">for(i in parent)&#123;</span><br><span class="line">if(parent.hasOwnProperty(i))&#123;</span><br><span class="line">if(typeof parent[i] === &quot;object&quot;)&#123;</span><br><span class="line">child[i] = (toStr.call(parent[i]) === &quot;[object Array]&quot;?)[]:&#123;&#125;;</span><br><span class="line">extendDeep(parent[i],child[i]);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">child[i] = parent[i]&apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、混入模式"><a href="#3、混入模式" class="headerlink" title="3、混入模式"></a>3、混入模式</h3><p>所谓的混入模式，就是将多个对象进行合并，组成一个新对象，该对象拥有对象的所有属性，可以建立一个<code>mix</code>函数进行混入，也仅为浅复制模式；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function mix()&#123;</span><br><span class="line">var i,</span><br><span class="line">prop,</span><br><span class="line">child=&#123;&#125;;</span><br><span class="line">for(i=0;i&lt;arguments.length;i++)&#123;</span><br><span class="line">for(prop in arguments[i])&#123;</span><br><span class="line">if(arguments[i].hasOwnProperty(prop))&#123;</span><br><span class="line">child[prop] = arguments[i][prop];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4、借用方法"><a href="#4、借用方法" class="headerlink" title="4、借用方法"></a>4、借用方法</h3><p>有时，并不需要达到继承，只是需要借用一两个方法。该情况下，可以使用apply( )与call( )方法。这两个函数可以改变函数中的this指向，两者的区别在于传入的第二个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent.doSomething.call(child,p1,p2,p3);</span><br><span class="line">parent.doSomething.apply(child,[p1,p2,p3]);</span><br></pre></td></tr></table></figure></p><h3 id="5、借用和绑定"><a href="#5、借用和绑定" class="headerlink" title="5、借用和绑定"></a>5、借用和绑定</h3><p>有时仅仅使用借用方法，会导致一些意想不到的错误，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var sayName = one.say;</span><br><span class="line">sayName(&apos;ho!&apos;)；  // 由于this的指向全局对象，会导致出错；</span><br></pre></td></tr></table></figure></p><p>此时，便需要有个绑定的方法来将一个对象与一个方法绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bind(o,m)&#123;</span><br><span class="line">return function()&#123;</span><br><span class="line">// slice方法不传参数时，将伪数组转换成数组；</span><br><span class="line">return m.apply(o,[].slice.call(arguments));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>该方法的代价便是额外的闭包开销；</p></blockquote>]]></content>
    
    <summary type="html">
    
      JavaScript语言编程核心（二）--- 代码的复用模式
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kmbk0.top/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语言编程核心（一）--- 对象</title>
    <link href="https://kmbk0.top/2019/12/01/JavaScript%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83(%E4%B8%80)%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
    <id>https://kmbk0.top/2019/12/01/JavaScript语言编程核心(一)—对象/</id>
    <published>2019-12-01T02:01:35.000Z</published>
    <updated>2020-01-14T12:50:36.293Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="JavaScript语言编程核心（一）—-对象"><a href="#JavaScript语言编程核心（一）—-对象" class="headerlink" title="JavaScript语言编程核心（一）— 对象"></a>JavaScript语言编程核心（一）— 对象</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>这是系列关于js语言核心思想的一些理解，包括对象、继承、原型链、构造函数、执行上下文堆栈、执行上下文、变量对象、活动对象、作用域链、闭包以及this。</p><p>本文参考自《JavaScript权威指南》、《JavaScript语言精粹》以及前端早读君的文章《javaScript核心》。</p><h2 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h2><p>在JavaScript中，对象是指可变的键控集合。属性名为字符串，值可以为任何类型的javascript值，每个属性都是一个名/值对。除了可以拥有属性外，对象还可以从一个称为原型的对象中继承属性。这就是JavaScript中的 <strong>“原型式继承”</strong>。</p><h4 id="1、属性特性："><a href="#1、属性特性：" class="headerlink" title="1、属性特性："></a>1、属性特性：</h4><p>在ES5中，属性还包括了一些标识可写、可枚举和可配置的特性。可以通过这些API给原型对象添加方法，并设置成不可枚举，让它们更像内置方法，也可以给对象定义不能修改或删除的属性，“锁定”该对象。<br>获取和定义可使用 <strong>getOwnPropertyDescriptor 和 defineProperty </strong> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">Object.defineProperty(o,&quot;x&quot;,&#123;</span><br><span class="line">value:2,</span><br><span class="line">writable:true,   // 可写性；</span><br><span class="line">enumerable:false,   // 可枚举性；</span><br><span class="line">configurable:true     //  可配置性;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(o,&quot;x&quot;));</span><br><span class="line">console.log(o.x);</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>可写，表明是否可以设置改属性的值；</li><li>可枚举，表明是否可以通过for/in循环返回；</li><li>可配置，表明是否可以删除或修改该属性；</li></ul></blockquote><h4 id="2、对象特性："><a href="#2、对象特性：" class="headerlink" title="2、对象特性："></a>2、对象特性：</h4><blockquote><ul><li>对象的原型属性（prototype）通过隐含的<code>__proto__</code>属性指向另一个对象，可以继承原型对象的属性；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf( )   // 可查询对象的原型；</span><br><span class="line">p.isPrototypeOf(o)   // 来检测p是否是o的原型；</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>对象的类（class）是一个表示对象类型的字符串，用以表示对象的类型信息，一般用toString( )来获取：[Object <em>class</em>]。<br>下面是封装好的 classof函数，用来检测对象类型；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function classof(o)&#123;</span><br><span class="line">if(o === null)&#123;return &quot;Null&quot;&#125;;</span><br><span class="line">if(o === undefined)&#123;return &quot;Undefined&quot;&#125;;</span><br><span class="line">return Object.ptototype.toString.call(o).slice(8,-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>对象的扩展标记（extensible flag）指明了是否可以向该对象添加新属性；ES5中，所有的内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是依据引擎所定义的；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.esExtensible( );   // 判断对象是否可扩展；</span><br><span class="line">Object.preventExtensions( ); // 将对象设置为不可拓展并且无法再转换回可拓展；但同样可以继承属性；</span><br><span class="line">Object.seal( );   // 封闭对象；将对象设置为不可拓展，而且将所有自有属性设置为不可配置；</span><br><span class="line">Object.isSealed( );  // 检测对象是否被封闭；</span><br><span class="line">Object.freeze( );   // 更严格的冻结对象，不可拓展，配置，且只读；</span><br><span class="line">Object.isFrozen( );   // 检测对象是否被冻结；</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="3、对象的分类："><a href="#3、对象的分类：" class="headerlink" title="3、对象的分类："></a>3、对象的分类：</h4><blockquote><ul><li>内置对象：JS内部定义的对象或类，如数组（Array）、函数（Function）、日期（Date）和正则表达式（RegExp）等；</li><li>宿主对象：由js解释器所嵌入的宿主环境中定义的对象，如浏览器客户端；</li><li>自定义对象：在JS代码中创建的对象；</li></ul></blockquote><h4 id="4、对象属性的分类："><a href="#4、对象属性的分类：" class="headerlink" title="4、对象属性的分类："></a>4、对象属性的分类：</h4><blockquote><ul><li>自有属性：在对象内部定义的属性；</li><li>继承属性：从原型对象中继承得到的属性；</li></ul></blockquote><h4 id="5、-对象的创建："><a href="#5、-对象的创建：" class="headerlink" title="5、 对象的创建："></a>5、 对象的创建：</h4><blockquote><ul><li>对象字面量法：<br>一个对象字面量就是包围在一对花括号中的若干个名/值对组成的映射表，名与值之间用<code>:</code>分隔，名值对间用<code>,</code>分隔。该方法的<code>__proto__</code>指向Object.prototype.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 注意，最后一个名/值对后不再添加逗号；</span><br><span class="line">var student = &#123;</span><br><span class="line">&quot;name&quot;:&quot;Tayde&quot;,</span><br><span class="line">&quot;age&quot;:26</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>new操作符+构造函数：<br>通过new操作符后跟一个函数，初始化创建出一个新的对象，该方法的<code>__proto__</code>指向构造函数.prototype。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object();  // 与 var o = &#123; &#125;效果一样；</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>ES5中的Object.create( ):<br>该方法可填两个参数，第一个填对象原型，第二选填自定义的属性；<code>__proto__</code>指向函数中填入的对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o1 = Object.create(&#123;x:1,y:2&#125;);  // 则o1对象已经继承了x,y属性；</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="6、对象属性的查询和设置："><a href="#6、对象属性的查询和设置：" class="headerlink" title="6、对象属性的查询和设置："></a>6、对象属性的查询和设置：</h4><blockquote><ul><li><code>.</code>运算符，当属性名为一个简单的标识符时，一个静态值时使用；优先考虑，因为它有更好的可读性；</li><li><code>[ ]</code>运算符，该方法更全面，当属性名为变量或动态值时使用；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name = student.name; </span><br><span class="line">var age = student[&quot;age&quot;];</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>Tips:<br>1、当属性不存在时，会返回 undefined，并不会报错；<br>2、但当查询属性的对象不存在时，则会报错；解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>3、可以用 <code>||</code>运算符来填充默认值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sex = student.sex || &quot;unknown&quot;;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="7、对象的引用："><a href="#7、对象的引用：" class="headerlink" title="7、对象的引用："></a>7、对象的引用：</h4><p>对象通过引用来传递，他们永远不会被复制。<br>对象并没有被复制，而是仅仅将x,y指向同一个对象的引用而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = &#123;a:1&#125;;</span><br><span class="line">var y = x;</span><br><span class="line">y.a = 2;</span><br><span class="line">console.log(x.a);   // 2;</span><br></pre></td></tr></table></figure></p><h4 id="8、对象属性的删除："><a href="#8、对象属性的删除：" class="headerlink" title="8、对象属性的删除："></a>8、对象属性的删除：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete student.name;</span><br><span class="line">delete student[&quot;age&quot;];</span><br></pre></td></tr></table></figure><blockquote><p>Tips：<br>delete操作符只能删除自身属性，无法删除原型上的继承属性；<br>delete操作符值是断开属性和宿主对象的联系，并不是删除属性，因此外部的引用仍会存在；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;x:&#123;y:1&#125;&#125;;</span><br><span class="line">var b = a.x;</span><br><span class="line">delete a.x;</span><br><span class="line">console.log(b);    // &#123;y:1&#125;;</span><br><span class="line">console.log(a.x);  // undefined;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="9、检测属性与对象的从属关系："><a href="#9、检测属性与对象的从属关系：" class="headerlink" title="9、检测属性与对象的从属关系："></a>9、检测属性与对象的从属关系：</h4><blockquote><p>1、in运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o =&#123;x:1&#125;;</span><br><span class="line">console.log(&quot;y&quot; in o);   // false;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2、hasOwnProperty( )：检测是否为自有属性，如果是继承属性，则返回false；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;x:1&#125;;</span><br><span class="line">console.log(o.hasOwnProperty(&quot;x&quot;));  // true;</span><br><span class="line">console.log(o.hasOwnProperty(&quot;toString&quot;));  // false;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>3、propertyIsEnumerable( ): 属于hasOwnProperty的增强版，只有当属性为自有属性且可枚举性时，才返回true;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;x:1&#125;;</span><br><span class="line">console.log(o.propertyIsEnumerable(&quot;x&quot;));  // true;</span><br><span class="line">console.log(o.hasOwnProperty(&quot;y&quot;));  // false;</span><br><span class="line">console.log(o.hasOwnProperty(&quot;toString&quot;));  // false;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>4、直接与undefined比较；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;x:1&#125;;</span><br><span class="line">o.x !== undefined;    // true;</span><br><span class="line">o.y !== undefined;    // false;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="10、对象属性的getter和setter"><a href="#10、对象属性的getter和setter" class="headerlink" title="10、对象属性的getter和setter:"></a>10、对象属性的getter和setter:</h4><p>在ES5中，对象的属性值可以用一个或两个方法替代，他们就是getter和setter。由这两个方法定义的属性称作“存取器属性”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var serialnum = &#123;</span><br><span class="line">&quot;$n&quot;:0,</span><br><span class="line">get next()&#123;</span><br><span class="line">return this.$n++;</span><br><span class="line">&#125;,</span><br><span class="line">set next()&#123;</span><br><span class="line">if(n&gt;=this.$n)&#123;this.$n = n;&#125;else&#123;throw &quot;新值必须大于当前值。&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="11、序列化对象："><a href="#11、序列化对象：" class="headerlink" title="11、序列化对象："></a>11、序列化对象：</h4><p>对象序列化是指将对象的状态转换成字符串，也可以将字符串转换为对象。使用ES5中的 JSON.stringify( ) 和 JSON.parse( )。</p><blockquote><p>1、NaN、Infinity和-Infinity序列化后的结果是Null;<br>2、函数、RegExp、Error对象和undefined值不能序列化和还原；<br>3、JSON.stringify( ) 只能序列化对象可枚举的自有属性；</p></blockquote><h4 id="12、对象方法："><a href="#12、对象方法：" class="headerlink" title="12、对象方法："></a>12、对象方法：</h4><blockquote><p>1、toString( )：无需参数，返回一个该对象的字符串。<br>2、toLocaleString( )：返回一个表示这个对象的本地化字符串。<br>3、toJSON( )：<br>4、valueOf( ):</p></blockquote>]]></content>
    
    <summary type="html">
    
      JavaScript语言编程核心（一）--- 对象
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kmbk0.top/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Gulp简要入门笔记</title>
    <link href="https://kmbk0.top/2019/11/23/Gulp%E7%AE%80%E8%A6%81%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://kmbk0.top/2019/11/23/Gulp简要入门笔记/</id>
    <published>2019-11-23T01:01:35.000Z</published>
    <updated>2020-01-14T13:57:18.702Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Gulp简要入门笔记"><a href="#Gulp简要入门笔记" class="headerlink" title="Gulp简要入门笔记"></a>Gulp简要入门笔记</h2><h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp:"></a>gulp:</h3><p>是一款基于node的前端自动化构建工具，它可以工程化完成许多重复性的各种文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件改动后重复这些步骤。因为这些过程其实是有规律可循，因此我们可以通过构建工具来帮助我们快速地自动化重复执行。</p><h4 id="流的思想："><a href="#流的思想：" class="headerlink" title="流的思想："></a><code>流</code>的思想：</h4><p><code>gulp</code>使用了node中的流<code>((stream))</code>管道思想，使数据像流水一样通过管道进行输出与输入，管道便是 <code>.pipe( )</code>，使用内存来过渡，而不是像<code>grunt</code>那样直接使用硬盘的直接写入，因此拥有更优秀的性能。</p><h4 id="简要工作流程："><a href="#简要工作流程：" class="headerlink" title="简要工作流程："></a>简要工作流程：</h4><blockquote><p>1、使用<code>gulp.src( )</code>找到目录下的 <code>.js</code>/<code>css</code>/<code>sass</code>等各种需要处理的 文件流；</p></blockquote><blockquote><p>2、通过<code>gulp.pipe( )</code>将文件流导入到各种插件中进行处理；</p></blockquote><blockquote><p>3、再次通过<code>gulp.pipe( )</code>将流传给<code>gulp.dest( )</code>,该指令可以将数据流写入到相应的目录文件中；</p></blockquote><h3 id="1、gulp的安装；"><a href="#1、gulp的安装；" class="headerlink" title="1、gulp的安装；"></a>1、gulp的安装；</h3><p>由于<code>gulp</code>依赖于<code>node</code>，因此在安装<code>gulp</code>之前需要先安装<code>node</code>;然安装之前可以先在终端中输入<code>node -v</code>用于确定环境是否已经安装node了。安装node可以通过直接在官网下载pkg安装包，<code>https://nodejs.org</code>;</p><p>安装完<code>node</code>后，会自带安装其包管理器<code>npm</code>，我们便可以通过它来进行<code>gulp</code>的安装了。</p><p>直接在终端中输入：<code>npm install -g gulp</code> ；</p><p>全局安装完<code>gulp</code>后，还需要在每个项目中单独安装，终端中进入到项目目录，执行终端命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp</span><br></pre></td></tr></table></figure></p><p>如果想创建时直接写入<code>package.json</code>，是使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p><h3 id="2、gulp-API学习"><a href="#2、gulp-API学习" class="headerlink" title="2、gulp API学习"></a>2、gulp API学习</h3><p><code>gulp</code>的API十分的简介清晰，常用的主要有：<br><code>gulp.src()</code>，<code>gulp.pipe()</code>,<code>gulp.task()</code>,<code>gulp.dest()</code>,<code>gulp.watch()</code>,<code>gulp.run()</code>;</p><h4 id="gulp-src-globs-options"><a href="#gulp-src-globs-options" class="headerlink" title="gulp.src(globs[, options]):"></a><code>gulp.src(globs[, options])</code>:</h4><p><code>globs</code>：字符串或数组，是文件匹配模式，可以通过文件路径来定位文件，获取文件流(stream)，后可以使用pipe管道输入到各种插件中；</p><p><code>[options]</code>：对象，可选参数；里面包含多个属性；</p><p><code>options.buffer</code>：类型： Boolean   默认值： true</p><p>如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。<strong>注意：</strong>插件可能并不会实现对 stream 的支持。</p><p><code>options.read</code>：类型： Boolean  默认值： true</p><p>如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。</p><p><code>options.base</code>：类型： String  </p><p>设置基准路径，影响导出文件路径，会使用传入<code>dest()</code>的路径替换掉 原始路径中<code>base</code>部分。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;client/js/**/*.js&apos;) // 匹配 &apos;client/js/somedir/somefile.js&apos; 并且将 `base` 解析为 `client/js/`</span><br><span class="line">  .pipe(minify())</span><br><span class="line">  .pipe(gulp.dest(&apos;build&apos;));  // 写入 &apos;build/somedir/somefile.js&apos;</span><br><span class="line"></span><br><span class="line">gulp.src(&apos;client/js/**/*.js&apos;, &#123; base: &apos;client&apos; &#125;)</span><br><span class="line">  .pipe(minify())</span><br><span class="line">  .pipe(gulp.dest(&apos;build&apos;));  // 写入 &apos;build/js/somedir/somefile.js&apos;</span><br></pre></td></tr></table></figure></p><h4 id="gulp-dest-path-options-："><a href="#gulp-dest-path-options-：" class="headerlink" title="gulp.dest(path[, options])："></a><code>gulp.dest(path[, options])</code>：</h4><p>该方法是可以将<code>pipe</code>导入的数据流写入对应的文件中。可以同时写入多个文件；如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;./client/templates/*.jade&apos;)</span><br><span class="line">  .pipe(jade())</span><br><span class="line">  .pipe(gulp.dest(&apos;./build/templates&apos;))</span><br><span class="line">  .pipe(minify())</span><br><span class="line">  .pipe(gulp.dest(&apos;./build/minified_templates&apos;));</span><br></pre></td></tr></table></figure></p><h4 id="gulp-task-name-deps-fn"><a href="#gulp-task-name-deps-fn" class="headerlink" title="gulp.task(name[, deps], fn):"></a><code>gulp.task(name[, deps], fn)</code>:</h4><p>该方法是用于定义<code>gulp</code>任务；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;taskname&apos;, function() &#123;</span><br><span class="line">  // 做一些事</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>deps</code>：类型：数组 可选参数，可定义一系列任务列表，将会在任务之前执行；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123;</span><br><span class="line">  // 做一些事</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>Tip：列表中的任务将被并行执行；</p></blockquote><h4 id="gulp-watch-glob-opts-tasks"><a href="#gulp-watch-glob-opts-tasks" class="headerlink" title="gulp.watch(glob[, opts], tasks):"></a><code>gulp.watch(glob[, opts], tasks)</code>:</h4><p>监视文件的变化，如果变化，则执行 <code>tasks</code>任务；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</span><br><span class="line">watcher.on(&apos;change&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="gulp-watch-glob-opts-cb"><a href="#gulp-watch-glob-opts-cb" class="headerlink" title="gulp.watch(glob[, opts, cb]):"></a><code>gulp.watch(glob[, opts, cb])</code>:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(&apos;js/**/*.js&apos;, function(event) &#123;</span><br><span class="line">  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="总结-gulp-API"><a href="#总结-gulp-API" class="headerlink" title="总结 gulp API:"></a>总结 gulp API:</h4><blockquote><p>gulp.task： 表示创建gulp任务；</p></blockquote><blockquote><p>gulp.src：输入的目录，通过 <code>*.js</code>可以匹配到js目录下的所有js文件；</p></blockquote><blockquote><p>gulp.pipe：管道指令，可以理解为加入执行队列；</p></blockquote><blockquote><p>gulp.dest：处理后的文件输出的目录；</p></blockquote><blockquote><p>gulp.watch：实时监控文件改变，一旦改变则马上执行任务；</p></blockquote><h3 id="3、自动加载配置中的插件，gulp-load-plugins；"><a href="#3、自动加载配置中的插件，gulp-load-plugins；" class="headerlink" title="3、自动加载配置中的插件，gulp-load-plugins；"></a>3、自动加载配置中的插件，gulp-load-plugins；</h3><p>我们可以在项目中为<code>gulp</code>保存一份配置文件：<code>package.json</code>，然后使用<code>gulp-load-plugins</code>这个插件便可以一次性加载配置中保存的所有插件；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">//加载gulp-load-plugins插件，并马上运行它</span><br><span class="line">var plugins = require(&apos;gulp-load-plugins&apos;)();</span><br></pre></td></tr></table></figure></p><h3 id="4、使用gulp进行JS的压缩，gulp-uglify；"><a href="#4、使用gulp进行JS的压缩，gulp-uglify；" class="headerlink" title="4、使用gulp进行JS的压缩，gulp-uglify；"></a>4、使用gulp进行JS的压缩，gulp-uglify；</h3><p>1、在项目中新建一个gulpfile.js文件，用于写入gulp配置代码；</p><p>2、安装<code>gulp-uglify</code>模块，终端输入：<code>npm install --save-dev gulp-uglify</code>;</p><p>3、在gulpfile.js中载入gulp模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取 gulp</span><br><span class="line">var gulp = require(&apos;gulp&apos;);</span><br></pre></td></tr></table></figure></p><p>4、载入<code>gulp-uglify</code>模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取 uglify 模块（用于压缩 JS）</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br></pre></td></tr></table></figure></p><p>5、创建<code>gulp</code>任务；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 压缩 js 文件</span><br><span class="line">gulp.task(&apos;javascript&apos;, function() &#123;</span><br><span class="line">    // 1. 找到文件</span><br><span class="line">    gulp.src(&apos;js/*.js&apos;)</span><br><span class="line">    // 2. 压缩文件</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">    // 3. 另存压缩后的文件</span><br><span class="line">        .pipe(gulp.dest(&apos;dist/js&apos;))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>6、终端执行，在终端中使用 <code>cd</code>进入到项目目录中，输入命令：<code>gulp javascript</code>;如果得到输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp script</span><br><span class="line">[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js</span><br><span class="line">[13:34:57] Starting &apos;script&apos;...</span><br><span class="line">[13:34:57] Finished &apos;script&apos; after 6.13 ms</span><br></pre></td></tr></table></figure></p><p>则任务执行成功；在目录的dist/js下，便可以看到已经压缩后的js文件；</p><h3 id="5、压缩HTML，gulp-minify-html："><a href="#5、压缩HTML，gulp-minify-html：" class="headerlink" title="5、压缩HTML，gulp-minify-html："></a>5、压缩HTML，gulp-minify-html：</h3><p>使用<code>gulp-minify-html</code>插件用来压缩html文件。任务如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">   minifyHtml = require(&quot;gulp-minify-html&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minify-html&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;src/*.html&apos;) // 要压缩的html文件</span><br><span class="line">    .pipe(minifyHtml())    //压缩</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/html&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="6、压缩CSS，gulp-minify-css："><a href="#6、压缩CSS，gulp-minify-css：" class="headerlink" title="6、压缩CSS，gulp-minify-css："></a>6、压缩CSS，gulp-minify-css：</h3><p>使用<code>gulp-minify-css</code>插件用来压缩css文件，任务如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    minifyCss = require(&quot;gulp-minify-css&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minify-css&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;src/*.css&apos;) // 要压缩的css文件</span><br><span class="line">    .pipe(minifyCss())    //压缩css</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/css&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="7、压缩图片，gulp-imagemin；"><a href="#7、压缩图片，gulp-imagemin；" class="headerlink" title="7、压缩图片，gulp-imagemin；"></a>7、压缩图片，gulp-imagemin；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var imagemin = require(&apos;gulp-imagemin&apos;);</span><br><span class="line">var pngquant = require(&apos;imagemin-pngquant&apos;); //png图片压缩插件</span><br><span class="line">gulp.task(&apos;default&apos;, function () &#123;</span><br><span class="line">    return gulp.src(&apos;src/images/*&apos;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            progressive: true,</span><br><span class="line">            use: [pngquant()] //使用pngquant来压缩png图片</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8、文件的重命名，gulp-rename；"><a href="#8、文件的重命名，gulp-rename；" class="headerlink" title="8、文件的重命名，gulp-rename；"></a>8、文件的重命名，gulp-rename；</h3><p><code>gulp</code>会以输入的文件流的名称来命名处理后的文件名，因此，如果需要重命名文件时，可以使用 <code>gulp-rename</code>插件；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">   rename = require(&apos;gulp-rename&apos;),</span><br><span class="line">   uglify = require(&quot;gulp-uglify&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;rename&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;src/1.js&apos;)</span><br><span class="line">    .pipe(uglify())           //压缩</span><br><span class="line">    .pipe(rename(&apos;1.min.js&apos;)) //会将1.js重命名为1.min.js</span><br><span class="line">    .pipe(gulp.dest(&apos;js&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="9、JS代码检查，使用-gulp-jshint；"><a href="#9、JS代码检查，使用-gulp-jshint；" class="headerlink" title="9、JS代码检查，使用 gulp-jshint；"></a>9、JS代码检查，使用 gulp-jshint；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">   jshint = require(&quot;gulp-jshint&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;jsLint&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;src/*.js&apos;)</span><br><span class="line">    .pipe(jshint())</span><br><span class="line">    .pipe(jshint.reporter()); // 输出检查结果</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="10、文件的合并，gulp-concat；"><a href="#10、文件的合并，gulp-concat；" class="headerlink" title="10、文件的合并，gulp-concat；"></a>10、文件的合并，gulp-concat；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">   concat = require(&quot;gulp-concat&quot;);</span><br><span class="line">gulp.task(&apos;concat&apos;, function () &#123;</span><br><span class="line">    gulp.src(&apos;src/*.js&apos;)     //要合并的文件</span><br><span class="line">    .pipe(concat(&apos;all.js&apos;))  // 合并匹配到的js文件并命名为 &quot;all.js&quot;</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/js&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="11、自动刷新，实时反馈代码的改变，gulp-livereload；"><a href="#11、自动刷新，实时反馈代码的改变，gulp-livereload；" class="headerlink" title="11、自动刷新，实时反馈代码的改变，gulp-livereload；"></a>11、自动刷新，实时反馈代码的改变，gulp-livereload；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">   less = require(&apos;gulp-less&apos;),</span><br><span class="line">   livereload = require(&apos;gulp-livereload&apos;);</span><br><span class="line">gulp.task(&apos;less&apos;, function() &#123;</span><br><span class="line">  gulp.src(&apos;less/*.less&apos;)</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(&apos;css&apos;))</span><br><span class="line">    .pipe(livereload());</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;watch&apos;, function() &#123;</span><br><span class="line">  livereload.listen(); //要在这里调用listen()方法</span><br><span class="line">  gulp.watch(&apos;less/*.less&apos;, [&apos;less&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该笔记参考于 <code>Nimo Chu</code>的github与前端乱炖社区文章《学习前端自动化构建工具Gulp》以及<code>gulp</code>官方文档；</p>]]></content>
    
    <summary type="html">
    
      Gulp简要入门笔记
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="笔记" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Gulp" scheme="https://kmbk0.top/blog/tags/Gulp/"/>
    
  </entry>
  
  <entry>
    <title>Mac终端常用命令</title>
    <link href="https://kmbk0.top/2019/11/15/Mac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://kmbk0.top/2019/11/15/Mac终端常用命令/</id>
    <published>2019-11-15T08:21:00.000Z</published>
    <updated>2020-01-14T12:52:37.619Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Mac终端常用命令"><a href="#Mac终端常用命令" class="headerlink" title="Mac终端常用命令"></a>Mac终端常用命令</h2><p>获取系统最高权限 ：<code>sudo -s</code>；</p><p>清理系统，也就是执行系统自带的清理脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo periodic daily;</span><br></pre></td></tr></table></figure></p><pre><code>sudo periodic weekly;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo periodic monthly;</span><br></pre></td></tr></table></figure><p>列出文件列表：<code>ls</code>;</p><p>切换目录： <code>cd</code>+ 路径;</p><p>建立新文件：<code>cd filename</code>;</p><p>拷贝文件：<code>cp -R /User/用户名/a /User/用户名/b/</code>;</p><p>移动文件：<code>mv -R /User/用户名/a /User/用户名/b/</code>;</p><p>删除文件：<code>rm</code>;</p><p>更改文件权限：<code>chmod</code>;</p>]]></content>
    
    <summary type="html">
    
      Mac终端常用命令
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="终端" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/%E7%BB%88%E7%AB%AF/"/>
    
    
      <category term="Mac" scheme="https://kmbk0.top/blog/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="https://kmbk0.top/2019/09/21/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://kmbk0.top/2019/09/21/CSS学习笔记/</id>
    <published>2019-09-21T11:01:35.000Z</published>
    <updated>2020-01-14T12:45:01.997Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="CSS学习笔记"><a href="#CSS学习笔记" class="headerlink" title="CSS学习笔记"></a>CSS学习笔记</h1><h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><ul><li><p>外部样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>内部样式表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;...&lt;style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li><li><p>内嵌样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color:red;margin-left:20px&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 我是注释；*/</span><br></pre></td></tr></table></figure><h3 id="浏览器私有属性："><a href="#浏览器私有属性：" class="headerlink" title="浏览器私有属性："></a>浏览器私有属性：</h3><blockquote><p>chrome、safari:  -webkit-;<br>firefox:  -moz-;<br>IE:-ms-;<br>opera: -o-;</p></blockquote><h3 id="语法规则："><a href="#语法规则：" class="headerlink" title="语法规则："></a>语法规则：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">margin:[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,4&#125;</span><br><span class="line">/*</span><br><span class="line">&lt;length&gt;:基本元素；</span><br><span class="line">`|`:组合符号；</span><br><span class="line">&#123;1,4&#125;:数量符号；</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>基本元素：<br>1、关键字： auto、solid、bold……<br>2、组合符号：</p><blockquote><p>空格：表示必须出现，且顺去固定；</p></blockquote><blockquote><p><code>&amp;&amp;</code>：必须出现，但顺序不固定；</p></blockquote><blockquote><p><code>||</code>：至少出现一个，但顺序随意；</p></blockquote><blockquote><p><code>|</code>：只能出现一个；</p></blockquote><blockquote><p><code>[]</code>：分组；</p></blockquote><blockquote><p><code>+</code>：可出现一次或多次；</p></blockquote><blockquote><p><code>？</code>：可出现也可不出现；</p></blockquote><blockquote><p><code>{}</code>：可以出现的次数；{2，4}：最少出现2次，最多出现4此；</p></blockquote><blockquote><p><code>*</code>：可出现0次，1次或多次；</p></blockquote><blockquote><p><code>#</code>：需出现1次或多次，需要用<code>,</code>隔开；</p></blockquote><h3 id="规则语法："><a href="#规则语法：" class="headerlink" title="规则语法："></a>规则语法：</h3><blockquote><p>@media：响应式布局时监听屏幕尺寸；</p></blockquote><blockquote><p>@keyframs：描述CSS动画帧；</p></blockquote><blockquote><p>@font-face：引入外部字体；</p></blockquote><blockquote><p>@import/@charset/@name space/@page/@supports/@document</p></blockquote><h3 id="选择器："><a href="#选择器：" class="headerlink" title="选择器："></a>选择器：</h3><h4 id="简单选择器："><a href="#简单选择器：" class="headerlink" title="简单选择器："></a>简单选择器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">标签选择器： tag&#123; &#125;</span><br><span class="line">类选择器：.className&#123; &#125;</span><br><span class="line">id选择器： #id&#123; &#125;</span><br><span class="line">通配符： *&#123; &#125;</span><br><span class="line">属性选择器： [disabled]&#123; &#125;/[type=button]&#123; &#125;</span><br><span class="line">   [class~=&quot;sports&quot;]&#123; &#125;   // 类名中包含sports,且以空格隔开；</span><br><span class="line">   [lang|=&quot;en&quot;]&#123; &#125;        // 类名中包含en，且以“-”隔开；</span><br><span class="line">   [href^=&quot;#&quot;]&#123; &#125;         // href属性值以 # 开头的元素；</span><br><span class="line">   [href$=&quot;pdf&quot;]&#123; &#125;       // href属性值以 pdf 结尾的元素；</span><br><span class="line">   [here*=&quot;lady&quot;]&#123; &#125;      // href属性值包含lady的元素；</span><br></pre></td></tr></table></figure><h4 id="伪类选择器："><a href="#伪类选择器：" class="headerlink" title="伪类选择器："></a>伪类选择器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a:link&#123; &#125;                 // 选中具有href的a标签样式；</span><br><span class="line">a:visited&#123; &#125;              // 已访问过的链接的样式；</span><br><span class="line">a:hover&#123; &#125;                // 当鼠标移上时的样式；</span><br><span class="line">a:active&#123; &#125;               //  当鼠标点击时的样式；</span><br><span class="line"></span><br><span class="line">:enabled&#123; &#125;  :disabled&#123; &#125;   :chedcked&#123; &#125;</span><br><span class="line"></span><br><span class="line">li:first-child&#123; &#125;  li:last-child&#123; &#125;       // 元素首项、末项</span><br><span class="line">li:nth-child(even)&#123; &#125;                     // 选中偶数项</span><br><span class="line">li:nth-child(3n+1)&#123; &#125;              // 选中正序第1、4、7。。。项</span><br><span class="line">li:nth-last-child(3n+1)&#123; &#125;         // 选中倒序第1、4、7。。。项</span><br><span class="line"></span><br><span class="line">li:only-child&#123; &#125;                 // 选中作为唯一子元素的的li标签</span><br><span class="line">dd:first-of-type&#123; &#125;              // 选中第一个dd类型的元素</span><br><span class="line">dd:last-of-type&#123; &#125;               // 选中最后一个；</span><br><span class="line">dd:nth-of-type&#123; &#125; </span><br><span class="line">span:only-of-type&#123; &#125;             // 选中同级元素只有一个span的&lt;span&gt;</span><br><span class="line"></span><br><span class="line">:empty&#123; &#125;   :root&#123; &#125;   :not()&#123; &#125;  </span><br><span class="line">:target()&#123; &#125;                // 选择器会突出显示当前活动的HTML锚;</span><br></pre></td></tr></table></figure><h4 id="组合选择器："><a href="#组合选择器：" class="headerlink" title="组合选择器："></a>组合选择器：</h4><blockquote><p>可以将简单选择器进行组合，如 img[src$=”jpg”]{ };</p></blockquote><h4 id="伪元素选择器："><a href="#伪元素选择器：" class="headerlink" title="伪元素选择器："></a>伪元素选择器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::first-letter&#123; &#125;;               /* 选择头字母；*/</span><br><span class="line">::first-line&#123; &#125;;                 /* 选择首行；*/</span><br><span class="line">/* 插入内容；*/</span><br><span class="line">::before&#123;content:&quot;before&quot;;&#125;</span><br><span class="line">::after&#123;content:&quot;after&quot;;&#125;</span><br><span class="line">/* 应用于被用户选中的内容 */</span><br><span class="line">::selection&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="后代选择器："><a href="#后代选择器：" class="headerlink" title="后代选择器："></a>后代选择器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">&lt;h2&gt;111&lt;/h2&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h2&gt;222&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;333&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.main h2&#123; &#125;                     // 选中111、222;</span><br><span class="line">.main&gt;h2&#123; &#125;                     // 选中111</span><br></pre></td></tr></table></figure><h4 id="兄弟选择器："><a href="#兄弟选择器：" class="headerlink" title="兄弟选择器："></a>兄弟选择器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">&lt;h2&gt;111&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;222&lt;/p&gt;</span><br><span class="line">&lt;p&gt;333&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">h2+p&#123; &#125;               // 选中与h2相邻的p：222；</span><br><span class="line">h2~p&#123; &#125;               // 选中h2同级之后的所有p:222,333;</span><br></pre></td></tr></table></figure><h4 id="选择器分组："><a href="#选择器分组：" class="headerlink" title="选择器分组："></a>选择器分组：</h4><blockquote><p>可以使用 <code>,</code>讲选择器合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1,h2,h3&#123; &#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="CSS选择器优先级："><a href="#CSS选择器优先级：" class="headerlink" title="CSS选择器优先级："></a>CSS选择器优先级：</h4><blockquote><table><thead><tr><th style="text-align:left">样式类型</th><th style="text-align:right">权重</th></tr></thead><tbody><tr><td style="text-align:left">a：行内样式</td><td style="text-align:right">1000</td></tr><tr><td style="text-align:left">b：id选择器</td><td style="text-align:right">100</td></tr><tr><td style="text-align:left">c：类、伪类和属性选择器</td><td style="text-align:right">10</td></tr><tr><td style="text-align:left">d：标签和伪元素选择器</td><td style="text-align:right">1</td></tr></tbody></table></blockquote><h5 id="value值-a-1000-b-100-c-10-d"><a href="#value值-a-1000-b-100-c-10-d" class="headerlink" title="value值 = a 1000 + b 100 + c* 10+ d ;"></a>value值 = a<em> 1000 + b</em> 100 + c* 10+ d ;</h5><blockquote><p>1、当value不等时，value值越大，则优先权更大；不同属性则合并，相同属性覆盖；<br>2、当value相等时，相同属性，后面的覆盖前面；不同属性合并；</p></blockquote><blockquote><blockquote><p>改变CSS优先级：<br>1、通过改变CSS里的前后顺序；<br>2、提升选择器的value值；<br>3、加入 !important. （优先使用1、2）；</p></blockquote></blockquote><h3 id="文本与颜色："><a href="#文本与颜色：" class="headerlink" title="文本与颜色："></a>文本与颜色：</h3><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-size:&lt;length&gt;|&lt;percentage&gt;|&lt;absolute-size&gt;|&lt;relative-size&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;length&gt;</code>: 例如14px;<br><code>&lt;percentage&gt;</code>: 例如200%/2em(2em/200% ：表示为父级字体大小的2倍)；<br><code>&lt;absolute-size&gt;</code>:例如small、large;<br><code>&lt;relative-size&gt;</code>: 例如smaller、larger;</p></blockquote><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family:[&lt;family-name&gt;|&lt;generic-family&gt;]#</span><br></pre></td></tr></table></figure><p>字体族名称(family-name)：是具体的字体名称, “Microsoft YaHei”</p><p> 类族名称(generic-family)：是字体类型名称而具体的字体则由浏览器决定,serif/sans-serif/cursive/fantasy/monospace等</p><blockquote><ul><li>font-family中设置的字体不会被浏览器自动下载, 字体是否可用则完全依靠用户电脑是否已安装该字体库而已；</li><li>属性值必须以类族名称(generic-family)结尾确保字体会以正确的形式解析渲染；</li><li>类族名称(generic-family)后的字体族名称(family-name)不会生效;</li></ul></blockquote><h4 id="字体粗细；"><a href="#字体粗细；" class="headerlink" title="字体粗细；"></a>字体粗细；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-weight:normal|bold|bolder|lighter|100|200...</span><br></pre></td></tr></table></figure><h4 id="斜体；"><a href="#斜体；" class="headerlink" title="斜体；"></a>斜体；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-style:normal|italic|oblique</span><br></pre></td></tr></table></figure><h4 id="行高；"><a href="#行高；" class="headerlink" title="行高；"></a>行高；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line-height:normal|&lt;number&gt;|&lt;length&gt;|&lt;percentage&gt;</span><br></pre></td></tr></table></figure><h4 id="设置linge-height-300-与设置line-height-3的区别："><a href="#设置linge-height-300-与设置line-height-3的区别：" class="headerlink" title="设置linge-height:300%与设置line-height:3的区别："></a>设置linge-height:300%与设置line-height:3的区别：</h4><blockquote><p>line-height：两行基线的间隔；<br>设置为300%时，直接以父元素的字体大小计算后继承，不管子元素自身的字体大小；既为父元素字体大小的3倍；（先计算后继承，为静态值）<br>设置为3时，则是动态的根据子元素自身的字体大小乘以3；（先继承后计算，为动态值，会自适应）；</p></blockquote><h4 id="利用line-height让多行文本垂直居中："><a href="#利用line-height让多行文本垂直居中：" class="headerlink" title="利用line-height让多行文本垂直居中："></a>利用line-height让多行文本垂直居中：</h4><p>在文本的后面添加个空白元素，设置其line-height和父元素高度一致，并在文本上设置vertical-align:middle;</p><h4 id="字体组合样式："><a href="#字体组合样式：" class="headerlink" title="字体组合样式："></a>字体组合样式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// font:italic bolid 20px/1.5 arial,serif;</span><br><span class="line">font:[&lt;font-style&gt;||&lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt;</span><br></pre></td></tr></table></figure><h4 id="字体颜色："><a href="#字体颜色：" class="headerlink" title="字体颜色："></a>字体颜色：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color:red;</span><br><span class="line">color:#ff0000;</span><br><span class="line">color:rgb(255,0,0);</span><br><span class="line">color:rgba(255.0.0.1)</span><br></pre></td></tr></table></figure><h3 id="对齐："><a href="#对齐：" class="headerlink" title="对齐："></a>对齐：</h3><h4 id="水平对齐：左对齐-右对齐-居中-两端对齐"><a href="#水平对齐：左对齐-右对齐-居中-两端对齐" class="headerlink" title="水平对齐：左对齐/右对齐/居中/两端对齐"></a>水平对齐：左对齐/右对齐/居中/两端对齐</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align:left|right|center|justify</span><br></pre></td></tr></table></figure><h4 id="垂直对齐："><a href="#垂直对齐：" class="headerlink" title="垂直对齐："></a>垂直对齐：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertical-align:baseline|sub|super|top|text-top|middle|bottom|text-bottom|&lt;percentage&gt;|&lt;length&gt;</span><br></pre></td></tr></table></figure><h4 id="文本缩进："><a href="#文本缩进：" class="headerlink" title="文本缩进："></a>文本缩进：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-indent:&lt;length&gt;|&lt;pencentage&gt;</span><br></pre></td></tr></table></figure><h3 id="换行，空格，自动换行："><a href="#换行，空格，自动换行：" class="headerlink" title="换行，空格，自动换行："></a>换行，空格，自动换行：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">white-space:normal|nowrap|pre|pre-wrap|pre-line</span><br></pre></td></tr></table></figure><blockquote><p>normal： 换行符、空格合并，自动换行；<br>nowrap：换行符、空格合并，不自动换行；<br>pre：换行符、空格保留，不自动换行；<br>pre-wrap：换行符、空格保留，自动换行；<br>pre-line：换行符保留、空格/tab合并，自动换行；</p></blockquote><h3 id="单词换行："><a href="#单词换行：" class="headerlink" title="单词换行："></a>单词换行：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word-wrap:normal|break-word;</span><br><span class="line">word-break:normal|keep-all|break-all;</span><br></pre></td></tr></table></figure><h3 id="文字阴影："><a href="#文字阴影：" class="headerlink" title="文字阴影："></a>文字阴影：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text-shadow:none|[&lt;length&gt;&#123;2,3&#125;&amp;&amp;&lt;color&gt;?]#;</span><br><span class="line">text-decoration:none|[underline||overline||line-through];</span><br></pre></td></tr></table></figure><blockquote><p>隐藏文本，且用省略号显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text-overflow:ellipsis;</span><br><span class="line">overflow:hidden;</span><br><span class="line">white-space:nowrap;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="定义鼠标形状："><a href="#定义鼠标形状：" class="headerlink" title="定义鼠标形状："></a>定义鼠标形状：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义|自适应|鼠标|消失|疑问|点击|放大|缩小|移动</span><br><span class="line">cursor:[&lt;url&gt;]*,[auto|default|none|help|pointer|zoom-in|zoom-out|move];</span><br></pre></td></tr></table></figure><h3 id="强制继承：-inherit"><a href="#强制继承：-inherit" class="headerlink" title="强制继承： inherit;"></a>强制继承： inherit;</h3><h3 id="盒模型："><a href="#盒模型：" class="headerlink" title="盒模型："></a>盒模型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// min-width,max-width用法一致；</span><br><span class="line">width:&lt;length&gt;|&lt;percentage&gt;|auto|inherit;</span><br><span class="line">// min-width,max-width用法一致；</span><br><span class="line">height:&lt;length&gt;|&lt;percentage&gt;|auto|inherit;</span><br><span class="line"></span><br><span class="line">// 顺序为 上，右，下，左</span><br><span class="line">padding:[&lt;length&gt;|&lt;percentage&gt;]&#123;1,4&#125;;</span><br><span class="line">margin:[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,4&#125;;</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="边框："><a href="#边框：" class="headerlink" title="边框："></a>边框：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">border:[&lt;border-width&gt;||&lt;border-style&gt;||&lt;border-color&gt;];</span><br><span class="line">border-width:[&lt;length&gt;]&#123;1,4&#125;;</span><br><span class="line">//             实线|虚线|点</span><br><span class="line">border-style:[solid|dashed|dotted]&#123;1,4&#125;;</span><br><span class="line">border-color:[&lt;color&gt;|transparent]&#123;1,4&#125;;</span><br></pre></td></tr></table></figure><h4 id="圆角边框："><a href="#圆角边框：" class="headerlink" title="圆角边框："></a>圆角边框：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-radius:[&lt;length&gt;|&lt;percentage&gt;]&#123;1,4&#125;[/[&lt;length&gt;|&lt;pencentage&gt;]&#123;1,4&#125;]?</span><br><span class="line">//                  水平半径     /     垂直半径</span><br><span class="line">border-radius: 0px 5px 10px 15px/20px 15px 10px 5px;</span><br><span class="line">border-top-left-radius:5px;</span><br></pre></td></tr></table></figure><h3 id="设置超出部分的样式："><a href="#设置超出部分的样式：" class="headerlink" title="# 设置超出部分的样式："></a># 设置超出部分的样式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//   overflow-x|overflow-y;</span><br><span class="line">//         可见|隐藏|出现滚动条|自动显隐滚动条；</span><br><span class="line">overflow:visible|hidden|scroll|auto;</span><br></pre></td></tr></table></figure><h4 id="切换盒子模型模式："><a href="#切换盒子模型模式：" class="headerlink" title="切换盒子模型模式："></a>切换盒子模型模式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:content-box|border-box|inherit;</span><br></pre></td></tr></table></figure><h4 id="盒阴影："><a href="#盒阴影：" class="headerlink" title="盒阴影："></a>盒阴影：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">box-shadow:none|&lt;shadow&gt;[,&lt;shadow&gt;]*</span><br><span class="line">&lt;shadow&gt;:inset?&amp;&amp;&lt;length&gt;&#123;2,4&#125;&amp;&amp;&lt;color&gt;?</span><br><span class="line">//水平偏移 垂直偏移 模糊半径 阴影大小 阴影颜色；</span><br><span class="line">box-shadow:4px 6px 3px 3px red;</span><br><span class="line">//  内阴影</span><br><span class="line">box-shadow:inset 0px 0px 5px red;</span><br></pre></td></tr></table></figure><h4 id="轮廓："><a href="#轮廓：" class="headerlink" title="轮廓："></a>轮廓：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outline:[&lt;out-width&gt;||&lt;outline-style&gt;||&lt;outline-color&gt;];</span><br><span class="line">outline-width:&lt;length&gt;;</span><br><span class="line">outline-style:solid|dashed|dotted;</span><br><span class="line">outline-color:&lt;color&gt;|invert;</span><br></pre></td></tr></table></figure><blockquote><p>与border值较为相似，但有两点区别：<br>1、border占据空间，而outline并不占据空间；<br>2、outline在border的外围；</p></blockquote><h3 id="背景-位于盒模型的最底层-："><a href="#背景-位于盒模型的最底层-：" class="headerlink" title="背景(位于盒模型的最底层)："></a>背景(位于盒模型的最底层)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-color:&lt;color&gt;；</span><br><span class="line">background-image:&lt;bg-image&gt;[,&lt;bg-image&gt;]*</span><br><span class="line">&lt;bg-image&gt; :&lt;image&gt;|none;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:<br>1、绝对路径：“http://….”;<br>2、相对路径，相对于根目录，CSS文件是相对于CSS文件，JS文件是相对于HTML的文件，<code>..</code>代表上一级：”../images/x.png”；</p></blockquote><h4 id="背景平铺方式："><a href="#背景平铺方式：" class="headerlink" title="背景平铺方式："></a>背景平铺方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background-repeat:&lt;repeat-style&gt;[,&gt;repeat-style&gt;]*</span><br><span class="line">//             X方向重复|Y方向重复|重复|留空隙平铺|伸缩铺满</span><br><span class="line">&lt;repeat-style&gt;:repeat-x|repeat-y|[repeat|space|round|no-repeat]&#123;1,2&#125;;</span><br><span class="line">//  x轴不重复，y轴重复</span><br><span class="line">background-repeat:no-repeat repeat;</span><br></pre></td></tr></table></figure><h4 id="背景固定方式："><a href="#背景固定方式：" class="headerlink" title="背景固定方式："></a>背景固定方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-attachment:&lt;attachment&gt;[,&lt;attachment&gt;]*</span><br><span class="line">//           背景随滚动而滚动|背景固定|继承</span><br><span class="line">&lt;attachment&gt;:scroll|fixed|inherit;</span><br></pre></td></tr></table></figure><h4 id="背景图片位置："><a href="#背景图片位置：" class="headerlink" title="背景图片位置："></a>背景图片位置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-position:&lt;position&gt;[,&lt;position&gt;]*</span><br><span class="line">&lt;position&gt;:left|center|right|top|bottom|&lt;percentage&gt;|&lt;length&gt;</span><br></pre></td></tr></table></figure><blockquote><p>background-position:10px 20px;   表示x轴偏移10px,y轴偏移20px；<br>background-position:20% 50%;  表示相对于父元素的定位；<br>background-position: center center;   图片居中；<br>background-position:right;  水平靠右，垂直居中；<br>background-position:right 10px top 20px;   与右边偏10px ,与上边偏20px；</p></blockquote><h4 id="常用的背景属性："><a href="#常用的背景属性：" class="headerlink" title="常用的背景属性："></a>常用的背景属性：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background:url(&quot;x.png&quot;) no-repeat 10px 10px;</span><br></pre></td></tr></table></figure><h4 id="设置背景参照盒子："><a href="#设置背景参照盒子：" class="headerlink" title="设置背景参照盒子："></a>设置背景参照盒子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-origin:&lt;box&gt;[,&lt;box&gt;]*</span><br><span class="line">&lt;box&gt;:border-box|padding-box|concent-box;</span><br></pre></td></tr></table></figure><h4 id="设置背景平铺的范围："><a href="#设置背景平铺的范围：" class="headerlink" title="设置背景平铺的范围："></a>设置背景平铺的范围：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-clip:&lt;box&gt;[,&lt;box&gt;]*</span><br><span class="line">&lt;box&gt;:border-box|padding-box|concent-box;</span><br></pre></td></tr></table></figure><h4 id="改变背景图片的大小："><a href="#改变背景图片的大小：" class="headerlink" title="改变背景图片的大小："></a>改变背景图片的大小：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background-size:&lt;bg-size&gt;[,&lt;bg-size&gt;]*;</span><br><span class="line">&lt;bg-size&gt;:[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,2&#125;|cover|contain;</span><br></pre></td></tr></table></figure><h4 id="组合："><a href="#组合：" class="headerlink" title="组合："></a>组合：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background:[&lt;bg-image&gt;||&lt;position&gt;[/&lt;bg-size&gt;]?||&lt;repeat-style&gt;||&lt;attachment&gt;||&lt;box&gt;||&lt;box&gt;]*&lt;bg-layer&gt;||&lt;background-color&gt;</span><br><span class="line"></span><br><span class="line">background:url(&quot;red.png&quot;) 0 0/20px 20px no-repeat,url(&quot;blue.png&quot;) 50% 50%/contain no-repeat content-box green;</span><br></pre></td></tr></table></figure><h4 id="背景的线性渐变："><a href="#背景的线性渐变：" class="headerlink" title="背景的线性渐变："></a>背景的线性渐变：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">linear-gradient( );</span><br><span class="line">[[&lt;angle&gt;|to &lt;side-or-corner&gt;],]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+;</span><br><span class="line">&lt;side-or-corner&gt;:[left|right]||[top|bottom];</span><br><span class="line">&lt;color-stop&gt;:&lt;color&gt;[&lt;percentage&gt;|&lt;length&gt;]?</span><br><span class="line"></span><br><span class="line">background-image:linear-gradient(red,blue);</span><br><span class="line">background-image:linear-gradient(to top right,red,blue);</span><br><span class="line">background-image:linear-gradient(45deg,red,blue);</span><br><span class="line">background-image:linear-gradient(red,green 20%,blue);</span><br></pre></td></tr></table></figure><h4 id="背景的径向渐变："><a href="#背景的径向渐变：" class="headerlink" title="背景的径向渐变："></a>背景的径向渐变：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background-image:radial-gradient(closest-side,red,blue);</span><br><span class="line">background-image:radial-gradient(circle,red,blue);</span><br><span class="line">background-image:radial-gradient(circle 100px,red,blue);</span><br><span class="line">background-image:radial-gradient(red,blue);</span><br><span class="line">background-image:radial-gradient(100px 50px,red,blue);</span><br></pre></td></tr></table></figure><blockquote><p>重复渐变：</p><p>background-image:repeating-linear-gradient( );</p><p>background-image:repeating-radial-gradient( );</p></blockquote><h3 id="布局："><a href="#布局：" class="headerlink" title="布局："></a>布局：</h3><h3 id="display"><a href="#display" class="headerlink" title="display:"></a>display:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:block|inline|inline-block|none;</span><br></pre></td></tr></table></figure><blockquote><ul><li><h4 id="display-block"><a href="#display-block" class="headerlink" title="display : block;"></a>display : block;</h4>块级元素，包括<code>&lt;div&gt;&lt;p&gt;&lt;h1&gt;..&lt;h6&gt;&lt;ol&gt;&lt;ul&gt;&lt;dl&gt;&lt;table&gt;&lt;form&gt;</code>…<br>特点：<br>1、占据整行；<br>2、 默认宽度为父元素宽度；<br>3、可设置宽高；</li></ul></blockquote><blockquote><ul><li><h4 id="display-inline"><a href="#display-inline" class="headerlink" title="display:inline;"></a>display:inline;</h4>行内元素，包括<code>&lt;span&gt;&lt;a&gt;&lt;i&gt;&lt;em&gt;&lt;label&gt;&lt;cite&gt;</code>…<br>1、宽度为内容宽度；<br>2、不可设置宽高；<br>3、同行显示；</li></ul></blockquote><blockquote><ul><li><h4 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display:inline-block;"></a>display:inline-block;</h4>内联块级元素，包括<code>&lt;input&gt;&lt;img&gt;&lt;textarea&gt;&lt;select&gt;&lt;button&gt;</code>…<br>1、默认宽度为内容宽度；<br>2、可设置宽高；<br>3、同行显示；<br>4、整块换行；</li></ul></blockquote><blockquote><ul><li><h4 id="display-none"><a href="#display-none" class="headerlink" title="display: none;"></a>display: none;</h4>元素不显示，且不占据空间；</li></ul></blockquote><blockquote><ul><li><h4 id="display-hidden"><a href="#display-hidden" class="headerlink" title="display: hidden;"></a>display: hidden;</h4>元素隐藏，但占据空间；</li></ul></blockquote><p>小技巧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 块级元素水平居中：</span><br><span class="line">.div&#123;margin:0 auto; width:900px;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//     默认定位| 相对定位 | 绝对定位| 固定定位</span><br><span class="line">positon:static|relative|absolute|fixed；</span><br><span class="line">// 配合属性：</span><br><span class="line">top/right/bottom/left/z-index:</span><br></pre></td></tr></table></figure><p>Tip：<br>1、如果同时设置了top与bottom，且没有设置高度时，则元素会被强制拉伸；如果设置了高，则不拉伸，显示为设定的高度；<br>2、z-index：设置层级，层级高的在顶层，会覆盖住层级低的元素。同时需要考虑父级元素的层级。</p><blockquote><ul><li><h4 id="position-relative"><a href="#position-relative" class="headerlink" title="position:relative;"></a>position:relative;</h4>其主要的用途是元素设置后作为子元素绝对定位的参照物；<br>1、仍处于文档流中；<br>2、参照物为元素本身；</li></ul></blockquote><blockquote><ul><li><h4 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position:absolute;"></a>position:absolute;</h4>绝对定位；<br>1、默认宽度为内容宽度；<br>2、脱离文档流；<br>3、参照物为父级第一个定位元素或者根元素；<br>用途：轮播图，定位….</li></ul></blockquote><blockquote><ul><li><h4 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position:fixed;"></a>position:fixed;</h4>固定定位；<br>1、默认宽度为内容宽度；<br>2、脱离文档流；<br>3、参照物为窗口；<br>用途：固定顶栏，遮罩…</li></ul></blockquote><h4 id="三行自适应布局："><a href="#三行自适应布局：" class="headerlink" title="三行自适应布局："></a>三行自适应布局：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.head&#123;positon:absolute;top:0;left:0;width:100%;height:100px;&#125;</span><br><span class="line">.body&#123;positon:absolute;top:100px;left:0;bottom:100px;right:0;overflow:auto;&#125;</span><br><span class="line">.foot&#123;positon:absolute;bottom:0;left:0;width:100%;height:100px;&#125;</span><br></pre></td></tr></table></figure><h3 id="float"><a href="#float" class="headerlink" title="float:"></a>float:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float:left|right|none|inherit;</span><br></pre></td></tr></table></figure><blockquote><p>1、默认宽度为内容宽度；<br>2、半脱离文档流；脱离元素文档流，但出于内容文档流中；<br>3、想指定方向一直移动；<br>4、设置了float属性的元素在同一文档流中；</p></blockquote><h4 id="清楚浮动的影响："><a href="#清楚浮动的影响：" class="headerlink" title="清楚浮动的影响："></a>清楚浮动的影响：</h4><p>1、空白元素：在浮动元素的后面添加一个空白元素；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;br class=&quot;cf&quot;&gt;</span><br><span class="line">.cf&#123;clear:both;height:0;overflow:hidden;visibility:hidden;&#125;</span><br></pre></td></tr></table></figure></p><p>2、claearfix：为设置float属性的元素的父元素添加类名“clearfix”;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;content:&quot;.&quot;;display:block;clear:both;height:0;overflow:hidden;visibility:hidden;&#125;</span><br><span class="line">.clearfix&#123;zoom:1&#125;</span><br></pre></td></tr></table></figure></p><h3 id="弹性flex布局"><a href="#弹性flex布局" class="headerlink" title="弹性flex布局"></a>弹性flex布局</h3><p>1、创建弹性容器flex container：(父级)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">display:flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、为容器设置成弹性容器后，处于文档流中的直接子元素自动变成弹性元素flex item。弹性元素的横向排列方向为<code>main axis</code>，纵向为<code>cross axis</code>。</p><p>排列方向：（弹性容器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//           横正向|   横逆向   |纵正向 |     纵逆向</span><br><span class="line">flex-direction:row|row-recerse|column|column-reverse;</span><br></pre></td></tr></table></figure></p><p>是否换行：（弹性容器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap:nowrap|wrap|wrap-reverse；</span><br></pre></td></tr></table></figure></p><blockquote><p>当设置为不换行时，会对弹性元素进行弹性收缩。</p></blockquote><p>上面两个属性可以合成为：（弹性容器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow:&lt;flex-derection&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure></p><p>定义弹性元素的排列顺序，<code>order</code>值，大的排在后面；（弹性元素）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order:&lt;interger&gt;;    // 整数，初始值为0；</span><br></pre></td></tr></table></figure></p><h4 id="弹性属性："><a href="#弹性属性：" class="headerlink" title="弹性属性："></a>弹性属性：</h4><p>设置弹性元素在main-axis上的宽度和高度；（弹性元素）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis:main-size|&lt;width&gt;;</span><br></pre></td></tr></table></figure></p><p>设置剩余空间的分配比例，如item1的 <code>flex-grow:1</code>；item2的<code>flex-grow:2</code>;则剩余的空间则按1/3,2/3分配给item1和item2；（弹性元素）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-grow:&lt;number&gt;;    // 初始值为0；</span><br></pre></td></tr></table></figure></p><p>设置当空间不足时，按比例收缩弹性元素，与<code>flex-grow</code>相对应；（弹性元素）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flew-shrink:&lt;number&gt;;   // 初始值为1;</span><br></pre></td></tr></table></figure></p><p>组合起来，可以设置为：（弹性元素）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 初始值为   0   1   main-size</span><br><span class="line">flew:&lt;flew-grow&gt;||&lt;flex-shrink&gt;||&lt;flex-basis&gt;</span><br></pre></td></tr></table></figure></p><h4 id="对齐属性："><a href="#对齐属性：" class="headerlink" title="对齐属性："></a>对齐属性：</h4><p>设置在主轴main-axis方向上的对齐方式。（弹性容器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content:flex-start|flex-end|center|space-between|space-around;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>flex-start</code>：左对齐；<br><code>flex-end</code>：右对齐；<br><code>center</code>：居中；<br><code>space-between</code>：中间间隔平分；<br><code>space-around</code>：首尾也分到间隔（当都设置宽度，且有剩余空间时）；</p></blockquote><p>设置辅轴cross-axis上的对齐（但弹性元素高度不一的时候）：（弹性容器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items:flex-start|flex-end|center|baseline|strech;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>flex-start</code>：上对齐；<br><code>flex-end</code>：下对齐；<br><code>center</code>：居中；<br><code>baseline</code>：内容对齐；<br><code>strech</code>：拉伸对齐；</p></blockquote><p>设置单个弹性元素在cross-axis上的对齐属性：（弹性元素）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self:auto|flex-start|flex-end|center|space-between|space-around|stretch;</span><br></pre></td></tr></table></figure></p><p>设置cross-axis方向上行对齐的方式：（弹性容器）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content:auto|flex-start|flex-end|center|space-between|space-around|stretch;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      CSS学习笔记
    
    </summary>
    
      <category term="教程" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="笔记" scheme="https://kmbk0.top/blog/categories/%E6%95%99%E7%A8%8B/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css" scheme="https://kmbk0.top/blog/tags/css/"/>
    
  </entry>
  
</feed>
