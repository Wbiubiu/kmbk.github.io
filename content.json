{"meta":{"title":"空梦博客-个人博客","subtitle":null,"description":"空梦的个人博客；主攻 Java、爬虫、WEB前端、数据库、数据分析、数据可视化 前后端框架；求知若饥，虚心若愚，一入 IT 深似海，从此学习无绝期，记录毕生所学！","author":"Mr. 空梦","url":"https://kmbk0.top"},"pages":[{"title":"404 Not Found","date":"2020-01-06T04:49:41.413Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"404.html","permalink":"https://kmbk0.top/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-01-08T11:52:13.627Z","updated":"2020-01-08T11:52:13.627Z","comments":true,"path":"about/index.html","permalink":"https://kmbk0.top/about/index.html","excerpt":"","text":"空梦博客一个小小的个人站， ㊣━━^-^o中华人民共和国o^-^━━㊣┃ 宠 粉 本 科 ┃┃ 毕 业 证 ┃㊣━━^-^o中华人民共和国o^-^━━㊣"},{"title":"我的朋友们","date":"2020-01-15T14:46:54.374Z","updated":"2020-01-15T14:46:54.374Z","comments":true,"path":"friends/index.html","permalink":"https://kmbk0.top/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 空梦博客头像： https://cdn.jsdelivr.net/gh/Wbiubiu/kmbk-cdn/favicon/km.png网址： https://kmbk0.top标签： 【这里就写你博客类型】"},{"title":"","date":"2020-01-06T04:49:42.429Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"projects/index.html","permalink":"https://kmbk0.top/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-06T04:49:42.348Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"blog/tags/index.html","permalink":"https://kmbk0.top/blog/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-06T04:49:42.306Z","updated":"2019-11-26T09:39:56.000Z","comments":true,"path":"blog/categories/index.html","permalink":"https://kmbk0.top/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用material-x主题如何自定义添加侧边栏小部件？","slug":"使用material-x主题如何自定义添加侧边栏小部件？","date":"2020-01-11T10:01:35.000Z","updated":"2020-01-14T09:58:06.477Z","comments":true,"path":"2020/01/11/使用material-x主题如何自定义添加侧边栏小部件？/","link":"","permalink":"https://kmbk0.top/2020/01/11/使用material-x主题如何自定义添加侧边栏小部件？/","excerpt":"使用material-x主题如何自定义添加侧边栏小部件？ 究竟如何添加？我们来一起看看吧！","text":"使用material-x主题如何自定义添加侧边栏小部件？ 究竟如何添加？我们来一起看看吧！ 描述先上Material X主题官网 戳我进官网 ^_^#&nbsp;官方文档 戳我进官方文档官方主题开源网站 戳我赢大奖啊ヽ(≧Д≦)ノ 注:我在这里就不多说了，对于如何搭建的想必你也知道怎么搭建。对于不知道如何搭建的朋友请看我前面的文章希望可以帮到你！好了，我也就不废话了。我们开始吧！ 开始教程第一步首先我们需要在主题的这个[\\themes\\material-x\\layout_widget]目录下创建你需要的新添加的侧边栏小部件的的名字xx.ejs&nbsp; 例如：tq.ejs &nbsp; 如下图 相应的目录下新建了一个tq.ejs 的文件 第二步在新建的tq.ejs写入你的自己需要添加的小部件配置代码了，我这里就拿我的侧边栏天气的插件做案例吧！ 以下是代码1234567&lt;section class=&apos;widget &lt;%- item.widget?item.widget:&apos;tq&apos; %&gt;&apos;&gt; &lt;%- partial(&apos;header&apos;, &#123;item: item, defIcon: &apos;&apos;, defTitle: &apos;&apos;&#125;) %&gt; &lt;div class=&apos;content &lt;%= theme.style %&gt;&apos;&gt; &lt;%- markdown(item.body) %&gt; &lt;/div&gt;&lt;/section&gt; 如下图 第三步写入代码完成后我们就要去主题文件下的_config.yml文件下配置啦！ 目录[\\themes\\material-x_config.yml] 这里呢，也是一样的我们需要新建一个widget 这个字段在官网也有教程，我们在这里也就不多说了哈~ (๑乛◡乛๑) 以下是代码12345- widget: tq icon: fas fa-cloud title: 天气预报 body: &apos;&lt;iframe name=&quot;weather_inc&quot; src=&quot;https://i.tianqi.com/index.php?c=code&amp;amp;id=7&quot; width=&quot;100%&quot; height=&quot;100&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;padding-left: 10px;&quot;&gt;&lt;/iframe&gt;&apos; 如下图 这里介绍一下widget以下所用到的字段： icon 小部件的左上角的图标 title小部件的名称 body小部件所需要的配置文件代码 闲言碎语这里都配置完成后我们就去使用。如何使用呢？这时就要看配置文件里面的说明了！或者看官方文档也是可以的，但是呢有很多人看不懂官方文档主要写的太官方化，这让我们这些小白何以理解啊！嘿嘿！(๑乛◡乛๑)&nbsp;(小声bb)m(-_-m)～你特喵的还废话~&nbsp;还不赶紧继续写教程。。。。 咳咳，话不多说开干！命苦啊！(ㄒoㄒ) 第四步这一步呢其实挺简单的，也就像是java对象进行调用就行了 &nbsp; (等会，说什么java啊！写的是hexo博客教程还跑去java了。。.(→_→)一脸嫌弃) 好好，我们言归正传哈！ 这么也就是调用一下刚刚写的那个widget字段配置就行了！这里说一下啊！官方给了我们自由选择的模式添加，例如在主页面的侧边栏添加啊、或者文章页面啊！等等。。这个看自己好吧，看自己需求自由发挥添加，毕竟谁都不想一直跟着别人走啊，总要玩点自己的新花样吧！Σ(ＴωＴ)努力– 如下图 这里是主题目录下的_config.yml配置 可以看到,这里我添加的两处位置，一个是主页，一个是文章的侧边栏 仔细看图中有红色圈圈的就可以明白了！已经注明很清楚了！ 问答 问：有盆友问我，这就完了？这么简单？？？ 答：别着急嘛！最开始我也是这样认为但是呢？其实不是的，这样的话你是无法展示出来的，代码是也不会生效。其实一开始我也是这样认为的，但是在我测试的时候却不是我想的那样。。。咋办捏，这时我们就要去考虑一个问题了，既然是新添加的小部件那我们肯定要去配置哪些小部件是生效的哪些不是，那么问题来了。这个主题配置究竟是不是这样子的呢？谁也说不准那就让我们继续往下看吧！ 第五步 闲言碎语看到这里我们就要执行最后一步的配置啦！(是不是很开心！我也要成功啦！其实是废话真tm多，感觉自己像一个 S* &nbsp;一样m(-_-m)～)咳咳，让我们言归正传 ，(其实归正几次了，都被我跑遍了！ 好了，不说这些了！) 首先呢这第五步啊！就是要在主题目录的[\\themes\\material-x\\layout_partial] 路径下找到side.ejs side：意思就是侧面、旁边然后进行添加我们自己新建的小部件，这里通俗点说，也就是需要在这里激活你所新建的小部件。如下图 图中所示：找到主题目录文件夹下的side.ejs 图中所示：添加的新键的tq小部件的调用 好了，这呢。也算是完成了！我们快去试试吧！ (此时此刻都已经按耐不住我那迫不及待的小心脏了！O(∩_∩)O 想要赶紧去一探究竟啦！) 我们在git 执行以下命令123hexo cleanhexo generatehexo deploy 好，执行完去看页面看效果！ 最后的效果 快看，我们成功了~ 问题是不是解决了？ 哈哈哈！所有的努力没白费！ 总结 闲言碎语 好啦，本次教程到此处就已经结束了，此教程呢也是为小白打基础所发布的，再说连小编我也是小白啊！( ＾∀＾) 本是同根生，相煎何太急。(释义：煮豆来做豆羹，过滤的豆子做成汁。豆杆在锅下燃烧，豆子在锅里哭泣。豆杆和豆子本是从同一条根上生长出来的，为什么要相互煎熬逼迫得那么狠呢？) 虽说油炸起来比较香一些。。。但是…(你tm 又跑偏了！你在总结，总结。回来) 哈哈！真S* 我们言归正传 (呃，这个 好像归了好几次了… 算了，三分归元气嘛~ )好，话题结束 本次总结我们在做新建小部件或者插件的时候，需要考虑的问题也就是这个配置到底是不是会自动配置为我们所调用呢？经过我们一番测试来看，我们上面的猜测是对的。这个主题呢~ 官方写的是死的，也就是说必须指定那些已经配置过的小部件然后才能调用和使用，所有呢我们在新建部件的话就要按照这个方法进行配置自行添加自己新建的部件啦！ 好啦，本期文章到此结束啦！(哎哟，可算结束了，累死我了！又是上传图片、又是打字总结的，嘘！这话不要讲，这么多朋友肯定会给你动力啊！加油！)如果您觉得有什么问题可以在下方留言哦！本帖留言已开！ 好了，今天就说这么多，我们下期再见！拜拜！","categories":[{"name":"记录","slug":"记录","permalink":"https://kmbk0.top/blog/categories/记录/"},{"name":"教程","slug":"记录/教程","permalink":"https://kmbk0.top/blog/categories/记录/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kmbk0.top/blog/tags/Hexo/"},{"name":"主题优化","slug":"主题优化","permalink":"https://kmbk0.top/blog/tags/主题优化/"},{"name":"配置","slug":"配置","permalink":"https://kmbk0.top/blog/tags/配置/"}]},{"title":"Markdown简明语法","slug":"Markdown简明语法","date":"2020-01-06T00:35:56.000Z","updated":"2020-01-14T12:52:59.836Z","comments":true,"path":"2020/01/06/Markdown简明语法/","link":"","permalink":"https://kmbk0.top/2020/01/06/Markdown简明语法/","excerpt":"","text":"#Markdown简明语法 Markdown是一种可以让人专注于内容与代码的轻量级的【标记语言】。让我们离开那些繁琐的排版与样式，专注于内容吧！！！ 标题在Markdown中，标题是使用 1-6个# 进行标记，分为六级：# 、##、###…… ，刚好对应h1~h6: 一级标题二级标题三级标题四级标题五级标题六级标题 区块与段落区块则是使用 &gt; 来进行标记： 这是一个区块啊！！！！ 可以通过首尾个空一行来形成一个段落，也就是类似于在HTML中以 &lt;p&gt;标签包起来：（注：官方语法推荐在标记的后面加入一个空格） 这是一个段落啊！我被&lt;p&gt;包住啦！ 有序列表与无序列表学过HTML的同学一定知道 &lt;li&gt;和&lt;ol&gt;,而在MD中，无序列表可以用 */+/-来进行标注：（通过行首加入tab，可标记二级列表） 小米 华为 苹果 oppo vivo 而有序列表则直接使用数字进行标记： 品牌 电器 物品 强调输出为HTML中的 &lt;strong&gt;\\&lt;em&gt;，使用 *和**包住强调的部分： 你好！我是一个 强调 哦！！你好！我是一个比你还厉害的二级 强调 哦！ 链接输出为HTML中的 &lt;a&gt;标签，使用 []直接包裹链接部分，后直接跟上()填入链接到的地址（也可以在地址后面 空格+title）： 你好！我叫度娘 戳我一下去我家啊； 图片输出为HTML中的 &lt;img&gt;标签，用法与标记链接基本一致： 我是一张图片](https://cdn.jsdelivr.net/gh/Wbiubiu/ImgHosting/biu/17.jpg&quot;Title&quot;)； 代码块当你需要在文章中添加代码时，比如 &lt;p&gt;hello world&lt;/p&gt; ，如果直接输入，则会变成 hello world p标签被直接翻译吃掉啦！因此，我们需要对代码块进行特殊的标识： 行内代码块： 使用反引号进行包裹： &lt;p&gt;hello world&lt;/p&gt; 块状代码块：使用tab对整体代码进行缩进； 1&lt;p&gt;hello world&lt;/p&gt; 表格MD的表格有点好玩，其实就是使用 |画出一个表格来，但其实这有点小麻烦： Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 小结熟练的使用上述的这些规则，应该就能应付平时的日常使用了，除了表格比较麻烦外，其它都简单易用。但需要多多联系，熟能生巧嘛。~在日后写博客的过程中，慢慢的掌握它！加油哦~~~","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://kmbk0.top/blog/tags/Markdown/"}]},{"title":"Sass基础用法","slug":"Sass基础用法","date":"2020-01-01T01:25:00.000Z","updated":"2020-01-14T12:53:44.179Z","comments":true,"path":"2020/01/01/Sass基础用法/","link":"","permalink":"https://kmbk0.top/2020/01/01/Sass基础用法/","excerpt":"","text":"#Sass基础用法 1、变量：Sass中的变量需要以 $开头进行命名，如 $blue;如果需要插入在字符串中，则需使用#{ }进行包裹；如：border-#{$de}-color; 2、计算：Sass允许在语句中直接使用算式记性计算，如：right: $var * 10; 3、嵌套：Sass可以使用语法的嵌套，可以使代码的可读性更强。如： (1) 标签嵌套123div&#123; h1&#123; &#125;;&#125; (2)属性嵌套：12345p&#123; border:&#123; color:red; &#125;&#125; TIPS：在嵌套的代码中，可以使用&amp;来引用父级，如123a&#123; &amp;:hover&#123; &#125;&#125; 4、注释：/* 注释 */：普通注释，会保留到编译后的文件中，如果使用压缩模式编译，则会省略； // 注释：只保留在Sass源文件中，编译后则省略； /*! 重要注释 */：压缩模式下编译也会保留； 5、继承：使用 @extend 可实现继承：12345.class1&#123; &#125;;.class2&#123; @extend class1; font-size:14px;&#125; 6、重用代码块：使用 @mixin进行代码块的定义，使用@include进行已定义的代码块的调用；12345678@mixin left&#123; float:left; margin-left:10px;&#125;div&#123; @include left;&#125; 在代码块的定义中，也可以传入参数和默认值：12345678@mixin left($value:10px)&#123; float:left； margin-right:$value;&#125;// 调用；div&#123; @include left(20px);&#125; 7、插入文件：可以使用 @import进行文件的引入：1@import &quot;path/filename.scss&quot;; 8、条件判断：使用 @if/@else写条件语句；1234567p&#123; @if 1+1 == 2&#123; width:10px; &#125;@else&#123; width:20px; &#125;&#125; 9、循环语句：for循环：12345@for $i from 1 to 10&#123; .border-#&#123;$i&#125;&#123; border:#&#123;$i&#125;px solid blue; &#125;&#125; while循环：1234567$i:6;@while $i&gt;0&#123; .item-#&#123;$i&#125;&#123; width:2em * $i; &#125; $i:$i-1;&#125; each语句：12345@each $menber in a,b,c,d&#123; .#&#123;$menber&#125;&#123; background:blue; &#125;&#125; 10、自定义函数：1234567@function double($n)&#123; @return $n * 2;&#125;#sidebar&#123; width:double(5px);&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://kmbk0.top/blog/tags/Sass/"}]},{"title":"分享一个IE6，7的CSS hack bug","slug":"share-a-css-hack","date":"2019-12-17T11:43:00.000Z","updated":"2020-01-14T12:54:04.869Z","comments":true,"path":"2019/12/17/share-a-css-hack/","link":"","permalink":"https://kmbk0.top/2019/12/17/share-a-css-hack/","excerpt":"","text":"一、分享一个IE6，7的css hack bug。 IE和我们之间，很多事情没法解释… ——多么痛的领悟 html:1234&lt;div id=\"main\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt; css:12345678910111213141516171819#main&#123; width: 200px; height: 50px; border: 1px solid #000; margin: 0 auto;&#125;#main .box&#123; width: 50px; height: 50px; margin-left: 10px; position: relative; float: left; background: #333;&#125;#main .box:hover&#123; z-index: 999; /*background: #333;*/ /*background: #999;*/&#125; .box设置了的四行核心代码是： float:left - 左浮动 margin-left: 10px - 左外边距为10px position: relative - 因为在box里面想用一个dom做绝对定位 background: #333 - 设置background颜色为#333当.box触发hover时，做了一步z-index的改变，这时候在IE6，7中出现bug：因margin-left失效，.box会向左移动10px；而且这时候设置margin-left是不起作用的，hover结束后.box也不会回到原来的位置。 二、淡定解决异次元的bug诡异的事情最后水落石出：background属性居然影响了margin。 将.box:hover多加一行background属性，比如：background: #999，这样子在IE上“看上去”就解决了。但是，就当你以为解决了bug的时候，如果.box:hover的background颜色设置与hover之前的颜色一样，也就是设置为background: #333，阴魂不散的bug又会重新出现啦。 庆幸你的需求是background颜色不一样吧。如果还真是悲剧到要做成一样的颜色，解决的办法恐怕只能是取消.box的position: relative，然后多加一层dom容器了。1234&lt;div class=\"box\"&gt; &lt;div style=\"position: relative\"&gt;…&lt;/div&gt; …&lt;/div&gt;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"css","slug":"css","permalink":"https://kmbk0.top/blog/tags/css/"}]},{"title":"JavaScript语言编程核心（四）--- 函数（待完成）","slug":"JavaScript语言编程核心(四)—函数(待完成)","date":"2019-12-16T05:21:00.000Z","updated":"2020-01-14T12:52:29.761Z","comments":true,"path":"2019/12/16/JavaScript语言编程核心(四)—函数(待完成)/","link":"","permalink":"https://kmbk0.top/2019/12/16/JavaScript语言编程核心(四)—函数(待完成)/","excerpt":"","text":"JavaScript语言编程核心（四）— 函数（待完成）在编程过程中，我们很经常会需要多次使用到一段代码，此时便需要把这段代码定义成函数，从而可以调用任意次。 函数是JavaScript中最出色的设计之一，它们是JS中基础模块单元，可用于代码复用，信息隐藏和组合调用。JS中的函数就是对象，也拥有自己的方法，它连接到Function.prototype上。 本文参考《JavaScript权威指南》； 函数的定义一般有两种方式可以创建函数：函数声明与函数表达式； 函数声明：123function add(a,b)&#123; return a+b;&#125; 这种形式的声明会被提前到作用域的顶部，所以可以在被定义之前调用它，称为 声明提前； 函数表达式：123var add = function(a,b)&#123; return a+b;&#125; 表达式的形式并不能在定义之前调用它，虽然var add也会被提前到作用域顶部，但赋值语句并不会被执行，此时add扔为undefined，所以只有在表达式定以后，才能进行函数的调用。 Tips：1、函数声明可以出现在全局代码中，也可以被嵌套在其它函数内，但根据规定，不能出现在循环，判断，try/catch/finally与with语句中。而函数表达式可以出现在任何地方。 2、定义在其它函数内部的函数，包含一个连接到外部上下文的连接[[scope]]，可以自由访问它的父函数中的参数与变量，这便是JS中的 闭包。 函数的调用调用一个已经定义好的函数有4种方式，会传入 实参，this, arguments。 1、函数调用模式可以直接在函数名称的后面加上()，传入参数完成函数的调用，如add(3,4)；此时，根据ES5或者ES5非严格模式，调用上下文( this )被指向全局对象；而在ES5严格模式中，this 则为 undefined； 因此可以这样来检测是否为严格模式：1var strict = (function()&#123;return !this;&#125;)(); 2、方法调用模式当一个函数被保存成一个对象的属性时，则成为一个方法，此时 this 指向保存该函数的对象。如 object.method()； 多数情况下，可以直接用 .符号来直接访问，但少数情况下可能需要使用[ ]来进行属性的访问操作。 方法链也称为 链式调用或级联调用，我们可以在一个方法中返回一个对象，从而可以继续调用它的方法。如JQuery中就是这么实现的；1$(&quot;.header&quot;).map().get().sort(); 这将使代码变得更为简洁和易读，因此当方法不需要返回值时，最好直接返回this。 thisthis是函数中的一个关键字 ，它指向函数的调用上下文，并不是变量，也不是属性名，因此不能对其进行赋值。 如果作为方法调用函数，则this指向保存该方法的对象； 如果在函数调用中，this可能指向全局或者undefined，因此，在闭包中，如果想访问父级的this，则通常是将this保存在一个变量里，便可以通过作用域链进行访问，一般可以命名为 self/that/me。 this总结： 1、全局环境中，则指向 全局对象（windows）。 2、构造函数里的this，则指向 新创建的对象； 3、函数中的this，指向 函数的调用者； 4、new Function，指向 全局对象（windows）; 5、eval中，指向调用上下文中的this； 构造函数调用模式如果函数或者方法调用之前带有关键字 new，它就构成构造函数式调用。构造函数的处理方式跟普通的调用在实参处理、调用上下文和返回值方面都有着不同。 1、当构造函数没有形参时，可以省略实参列表和圆括号； 2、new操作符的操作步骤可以分成3步： （1）创建一个新对象； （2）新对象继承构造函数的prototype属性，this指向该新对象，也就是说，就算即使使用new o.m()，函数中的this值也是指向新对象，而不是o； （3）执行函数语句，为新对象添加属性，方法； （4）返回该新对象；通常，构造函数中不适用return，但如果有主动return一个对象，则返回该对象；如果没有返回或者返回一个原始值，则返回最初创建的对象； 间接调用使用call()和apply()可以间接地调用函数，它们可以显式地指定this值，也就是说，任何函数都可以作为任何对象的方法来调用。 call(this,p1,p2,p3)：以自己的实参列表作为传入函数的实参；apply(this,[p1,p2,p3])：以数组的形式传入实参； 函数的实参与形参1、实参数量少于形参调用函数时，当实参的数量少于定义的形参时，则后面的形参的值均为undefined。因此，在设置形参的时候，理想的情况是为参数设置一个合理的默认值，可以使用下面的形式：1a = a || 0; // 形参设置为 a 但传入的实参和形参只是以顺序的位置对应，并无法主动地为他们指定关系，也就是说，无法省略第一个实参，而直接传入第二个实参，必须填入占位的undefined或者null，因此可选的形参只能放在是参列表的最后。推荐对可选参数进行清晰的注释。 2、实参数量多于形参调用函数式，当实参的数量大于定义的形参时，可以通过参数对象来获取超过部分的实参。这个对象称为 arguments，是一个类数组，包含着传入的所有实参列表，它可以通过类似于数组的[0],[1]进行索引，访问传入的实参。同时，它还拥有可以length的属性，可以获取到传入函数的实参数量。 该对象有一个重要的用处，既让函数可以处理不定数量的实参，这种函数也成为 不定实参函数（varargs function）。比如，求任意个数字的总和，便可以定义为：12345678910111213var add = function()&#123; var sum = 0, i; l = arguments.length; // 遍历实参对象，累加每一个实参； for(i=0;i&lt;l;i++)&#123; sum += arguments[i]; &#125; // 返回结果； return sum;&#125;var sum = add(1,2,3,4,5); // sum为15； Tips:1、实参对象arguments其实是实参的一个指针数组，并不是一个真正的数组，也就是说，上面函数中，arguments[0] === 1的值为 true。在非严格模式下，可以通过实参对象来修改传入函数的实参的值。 2、实参对象还包含两个值，callee和caller。在严格模式下，不能对这两个值进行读写操作，但在非严格模式下，callee指向当前函数本身，caller则指向调用函数的函数。 3、记住定义的形参顺序，是个麻烦的事，因此可以使用直接传入对象，对象中是一个所有参数的键值对集合。 4、合理的实参类型检测，是避免函数执行错误的保证。 自定义函数属性由于函数的本质也是一个特殊的对象，它也可以拥有自己的属性。当有些函数需要一些静态的值时，其实可以将其保存在函数的自身属性中，从而避免保存到全局环境中。12345678function integer()&#123; return integer.counter++;&#125;integer.counter = 0;// 点击一次，计时器累加1；$(document).on(&quot;click&quot;,function()&#123; console.log(integer());&#125;) 作为命名空间的函数一般，我们会避免在全局环境中添加变量，避免污染全局的命名空间，一个很好的解决方法，便是将代码放置于一个函数作用域内。一般使用匿名的立即执行函数：123(function()&#123; // 模块代码;&#125;)();","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"JavaScript语言编程核心（三）--- 执行上下文与作用域","slug":"JavaScript语言编程核心(三)—执行上下文与作用域","date":"2019-12-05T00:21:00.000Z","updated":"2020-01-14T12:51:00.278Z","comments":true,"path":"2019/12/05/JavaScript语言编程核心(三)—执行上下文与作用域/","link":"","permalink":"https://kmbk0.top/2019/12/05/JavaScript语言编程核心(三)—执行上下文与作用域/","excerpt":"","text":"JavaScript语言编程核心（三）— 执行上下文与作用域执行上下文（EC）执行上下文：可以抽象为一个简单的对象，在一个函数或者eval( )被执行时创建，对象里面包含着一些代码运行所需的属性，统称为 上下文状态。一个上下文状态由三个结构组成： 变量对象(variable Object); 作用域链(scope chain)； this指向(thisValue)； 执行上下文堆栈一般可以认为有三种执行上下文： 全局执行上下文； 函数执行上下文； eval执行上下文； 一个执行上下文可以触发另一个上下文，以栈的形式实现，称为执行上下文堆栈。 触发其它上下文的叫做 caller，而被触发的上下文叫做 callee； 1.当代码执行的时候，首先生成一个全局执行上下文（global EC）。 2.当执行到函数作用域时，全局执行上下文（caller）会触发该函数执行上下文(callee)，将控制权传递给callee，而此时caller则暂缓执行。callee被push到栈的最顶层，拥有控制权，成为当前运行的执行上下文(active EC)。 3.当callee执行结束后，控制权会返还给caller，callee从栈顶层被pop除，caller继续往下执行。 变量对象(VO)变量对象是执行上下文中的一个数据作用域，存储着上下文中所定义的变量和函数声明（不包括函数表达式）。 全局上下文的变量对象就全局对象本身。 活动对象（AO）当函数被caller触发时，该函数的变量对象（VO）则会被激活成为活动对象（AO），里面加入了形参和arguments对象。 作用域作用域：通俗点可以理解为是一段代码或者一个变量的作用范围，是程序源代码中定义这个变量的区域，可以简单的理解为一个对象，其实，变量对象便是作用域的实体。比如，一个全局变量，就拥有全局的作用域，在JavaScript代码的所有地方都有定义，都可以进行访问，理解为一个全局对象中定义着这个全局属性。 在许多编程语言中，每个花括号中的代码都具有各自的作用域，而在花括号的外部，是不可见的，这称为 块级作用域(block scope)。但在JavaScript中，虽然语法上也是使用花括号，但并不存在块级作用域，在花括号内定义的变量，在外部都是可见的。取而代之的是函数作用域(function scope)：在一个函数中声明的变量，在该函数，包括其内部嵌套函数中，都是有定义，可见的。但在函数的外部是不可见的。 因此，这里就引出了另一个概念– 声明提前。根据函数作用域的定义，一个声明在函数体内的任何地方都是始终可见的，甚至在声明之前。因此，就算在声明一个变量之前，也是可以访问到这个变量的（但不涉及到赋值）。1234567var scope = &quot;global&quot;;(function()&#123; // 并不是输出global，这是因为声明提前，等于在该语句前加了一句，var scope。但并不涉及赋值； console.log(scope); // undefined； var scope = &quot;local&quot;; console.log(scope); // local;&#125;)(); 作用域链在定义一个函数作用域时，会随之产生一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表，列表内包含所有父级变量对象和自身的活动对象，另外，通过with语句和catch语句也可动态的延长作用域链。 作用域链其实是由两部分组成的：函数内部属性 [[scope]] + 自身活动对象(AO)；在[[scope]]属性中，保存着父级函数的作用域链。 当在函数内访问一个变量时，首先会从该函数自身的活动对象中查找，如果不存在，则会沿着作用域链往上一级一级查找父级变量对象。 闭包由于在JavaScript中，函数属于第一级对象，即可以当成参数传入一个函数，也可以从函数中返回出一个函数。此时，便会出现一个问题，当一个父函数执行后返回另一个子函数后，便会被摧毁，而此时，返回的子元素的[[scope]]属性中仍然保存着父函数的作用域链，以此来解决访问父函数中变量的问题。 这种类型的作用域，成为静态（词法）作用域。12345678var afun = (function()&#123; var a = 1; return function afun()&#123; alert(a); &#125;&#125;)();var a = 2;afun(); // 1 静态作用域是闭包存在的一个必需条件，因此 闭包可以定义为： 一个函数，和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。 Tips：从理论上讲，每一个函数都可以称为闭包，因为都包含了[[scopte]]属性。 当在一个父函数中定义了两个子函数时，此时两个子函数拥有相同的[[scope]]属性，而且是共享的。也就是说，改变一个闭包中的变量，会影响到另一个闭包中的变量。这也就是我们最常见的闭包问题的根源所在：12345678910var a = [];for(var i = 0;i&lt;10;i++)&#123; a[i] = function()&#123; console.log(i); &#125;&#125;// 而不是预期中的 0~9，其原因就是这9个函数共享一样的[[scope]]属性；a[0](); // 10;a[1](); // 10;a[9](); // 10; 可以通过将参数i以参数的形式传入，让其不需要从[[scope]]属性中进行查找。1234567891011var a = [];for(var i = 0;i&lt;10;i++)&#123; a[i] = (function(x)&#123; return function()&#123; console.log(x); &#125; &#125;)(i);&#125;a[0](); // 0;a[1](); // 1;a[9](); // 9;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"JavaScript语言编程核心（二）--- 代码的复用模式","slug":"JavaScript语言编程核心(二)—代码的复用模式","date":"2019-12-03T04:01:00.000Z","updated":"2020-01-14T12:51:58.154Z","comments":true,"path":"2019/12/03/JavaScript语言编程核心(二)—代码的复用模式/","link":"","permalink":"https://kmbk0.top/2019/12/03/JavaScript语言编程核心(二)—代码的复用模式/","excerpt":"","text":"JavaScript语言编程核心（二）— 代码的复用模式在大多数编程语言中，代码复用都是很重要的一块内容，而代码的继承性，是代码复用的一种重要形式，可以显著地减少开发成本，提高开发效率。继承的方式可以大致的分成两类：1、传统的类式继承；2、现代化继承方式：包括原型继承、复制属性继承、混入、借用、借用与绑定。 构造函数在JavaScript中，构造函数其实也是一类普通函数，但它有几个特点： 1、函数名首字母大写，以区分普通函数；2、通过this创建新的属性和方法；3、配合new操作符，可创建出一个新对象； new操作符new操作可以配合函数，返回一个对象，实际上它是做了三件事情： 1、创建一个新对象； var _obj = {}；2、使_obj继承该函数的原型；obj.__proto__ = CO.prototype;3、执行函数中的语句，为this指向添加属性、方法；4、返回该新对象； Tips：如果函数中有主动return一个对象，则返回该对象，否则隐式返回_obj;如果忘记使用new，则会造成在全局中添加属性和方法，这是很糟糕的。因此不要忘记new！为了避免当忘记new时，不会出现意外，便出现了一种模式，称为 自调用构造函数，它可以使得 var a = new CO()与var a = CO()效果一致；123456789function Person()&#123; if(!(this instanceof Person))&#123; return new Person(); &#125; this.name = &quot;dong&quot;;&#125;Person.prototype.sayName = function()&#123; alert(this.name);&#125; 类式继承实现类式继承的目标，是通过构造函数Child( )来获取一个父类构造函数Parent( )的属性，然后再由new Child( )实例化对象，实现继承。因此，关键的步骤就是 inherit(Child,Parent); 这里，有多种模式可以完成这样的继承函数： 1、默认模式：123function inherit(c,p)&#123; c.prototype = new P();&#125; Tips:对象指向原型，使用对象内部的__proto__属性，指向一个实例对象。但该属性不符合W3C标准，不能使用，但可以让我们更好的理解JS的原型继承的概念；构造函数指向原型，使用prototype属性，也是指向一个实例对象；通过默认模式完成的继承，属性与方法并不在自身上，只是通过原型链查找到的，仅仅是获取到引用，而且无法通过子构造函数传参。 2、借用构造函数：123function Child(a,b,c,d)&#123; Parent.apply(this,arguments);&#125; 该方法是只可以继承父级构造函数中添加到this的属性，原型中的属性并不能继承。但相比于第一种默认方式，它继承的属性都变成了自身属性，即hasOwnProperty为true，而不是从原型链上查找到的属性。 通过该模式，可以实现多重继承，即同时继承多个父级函数的属性；1234function Child()&#123; Father.apply(this,arguments); Mother.apply(this,arguments);&#125; 该模式的优点是，继承后的子级是父级函数的真实副本，操作子级函数并不会影响或覆盖父级函数。而缺点，便是无法从原型中继承属性，而是为每个实例都初始化各自的方法属性。 借用与设置原型为了解决借用模式的缺点，我们可以为其设置原型来解决。1234function Child()&#123; Parent.apply(this,arguments);&#125;Child.prototype = new Person(); 这样既能得到父级函数中属性的真是副本，又可以继承到原型上的方法。但仍然是有缺点，便是该模式调用了两次Parent构造函数，属性被继承了两次，导致了效率的低下。 共享原型该模式有点类似于第一种默认方式，但是不同点在于，将子函数的原型直接指向父级构造函数的原型。123function inherit(c,p)&#123; c.prototype = p.prototype;&#125; 只要将要复用的属性，方法都放在父级的原型里，即可以达到继承的目的。但是该模式的缺点在于，当修改了继承的子级的原型时，便直接影响到了该类中的所有对象。 代理构造函数模式通过创建一个代理构造函数，链接父级函数的原型与子级函数，从而避免了共享原型所带来的弊端，而且可以利用原型链的优势。12345function inherit(c,p)&#123; var F = function()&#123;&#125;; F.prototype = p.prototype; c.prototype = new F();&#125; Tips：该模式不会继承父级构造函数上this的属性，只会继承父级原型上的属性。更近一步，可以将父级构造函数和其原型的存为子级构造函数的一个指针，以备不时之需；12c.uber = p.prototype;c.prototype.constructor = c; 综上可以整理出最后，也是JS中较为完美的类式继承模式，也称为 圣杯模式；最后一点优化，便是使用即时执行函数和闭包，优化每次都需要创建一个新的代理函数的缺点。 圣杯模式123456789var inherit = (function(c,p)&#123; var F = function()&#123;&#125;; return function(c,p)&#123; F.prototype = p.prototype; c.prototype = new F(); c.uber = p.prototype; c.prototype.constructor = c; &#125;&#125;)(); Klass语法糖12345678910111213141516171819202122232425262728293031323334var klass = function(Parent,props)&#123; var Child,F,i; // 1. // 新构造函数； Child = function()&#123; if(Child.uber &amp;&amp; Child.uber.hasOwnProperty(&quot;__construct&quot;))&#123; Child.uber.__construct.apply(this,arguments); &#125; if(Child.prototype.hasOwnProperty(&quot;__construct&quot;))&#123; Child.prototype.__construct.apply(this,arguments); &#125; &#125; // 2. // 继承; Parent = Parent || Object; F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.uber = Parent.prototype; Child.prototype.constructor = Child; // 3. // 添加实现方法： for(i in props)&#123; if(props.hasOwnProperty(i))&#123; Child.prototype[i] = props[i]; &#125; &#125; // 4. // 返回该Child; return Child;&#125; 现代化继承方式1、原型继承：对象可以通过为它指定原型对象而完成继承，这样的继承称为委托继承，也可以称为原型继承。原型对象也是一个简单的对象，此时也可以继续为它指定它的原型对象而完成继承。此时，由 实例对象 —&gt; 原型对象 —&gt; 原型对象…，这样构建出来的一条线，便称为原型链。 原型链：是由原型对象组成，是一个用来实现继承和共享属性的有限的对象链。 属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined； 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用：b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。 1、通过__proto__来实现原型继承，从测试代码可以看出，b对象继承了a对象的x属性，同时a对象继承于顶级的原型对象 Object.prototype。因此则组成了一条原型链： b —&gt; a —&gt; Object.prototype;1234567// var a = &#123;x:1&#125;;var b = &#123;&#125;;b.__proto__ = a;console.log(b.x); // 1；console.log(a.__proto__ == Object.prototype); // true;console.log(b.__proto__ == Object.prototype); // false; 2、第二种方式可以使用ES5中的Object.create( )方法来实现原型的继承：也就是可以通过给一个函数F，直接通过prototype指定一个实例对象作为原型，完成继承。1234567891011// 低版本浏览器的兼容；if(!Object.create)&#123; Object.create = function(o)&#123; if(arguments.length&gt;1)&#123; throw new Error(&quot;只接受第一个参数&quot;); &#125; function F()&#123;&#125;; // 创建一个新对象； F.prototype = o; // 将新对象的原型对象指向传入对象； return new F(); // 返回该对象的实例； &#125;&#125; 2、通过复制属性实现继承这种模式中，对象将从另一个对象中以直接复制的形式继承属性，可以由一个extend( )实现复制继承。 浅复制：如果对象中的属性是对象，那只是简单的进行引用的复制。会导致修改子对象的对象属性，则父对象的属性也会被修改；1234567891011function extend(parent,child)&#123; var i; child = child || &#123;&#125;; // 遍历父对象的属性，判断是否为自身属性； for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; child[i] = parent[i]; &#125; &#125; return child;&#125; 深复制：以浅复制的形式，增加判断，当遇到属性是对象时，则递归进行更深一步的复制；1234567891011121314151617function extendDeep(parent,child)&#123; var i, toStr = Object.prototype.toString; child = child || &#123;&#125;; // 遍历父对象属性，先判断是否为自身属性，后属性值判断是否为对象； for(i in parent)&#123; if(parent.hasOwnProperty(i))&#123; if(typeof parent[i] === &quot;object&quot;)&#123; child[i] = (toStr.call(parent[i]) === &quot;[object Array]&quot;?)[]:&#123;&#125;; extendDeep(parent[i],child[i]); &#125;else&#123; child[i] = parent[i]&apos;&apos; &#125; &#125; &#125; return child;&#125; 3、混入模式所谓的混入模式，就是将多个对象进行合并，组成一个新对象，该对象拥有对象的所有属性，可以建立一个mix函数进行混入，也仅为浅复制模式；12345678910111213function mix()&#123; var i, prop, child=&#123;&#125;; for(i=0;i&lt;arguments.length;i++)&#123; for(prop in arguments[i])&#123; if(arguments[i].hasOwnProperty(prop))&#123; child[prop] = arguments[i][prop]; &#125; &#125; &#125; return child;&#125; 4、借用方法有时，并不需要达到继承，只是需要借用一两个方法。该情况下，可以使用apply( )与call( )方法。这两个函数可以改变函数中的this指向，两者的区别在于传入的第二个参数。12parent.doSomething.call(child,p1,p2,p3);parent.doSomething.apply(child,[p1,p2,p3]); 5、借用和绑定有时仅仅使用借用方法，会导致一些意想不到的错误，如：12var sayName = one.say;sayName(&apos;ho!&apos;)； // 由于this的指向全局对象，会导致出错； 此时，便需要有个绑定的方法来将一个对象与一个方法绑定：123456function bind(o,m)&#123; return function()&#123; // slice方法不传参数时，将伪数组转换成数组； return m.apply(o,[].slice.call(arguments)); &#125;;&#125; 该方法的代价便是额外的闭包开销；","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"JavaScript语言编程核心（一）--- 对象","slug":"JavaScript语言编程核心(一)—对象","date":"2019-12-01T02:01:35.000Z","updated":"2020-01-14T12:50:36.293Z","comments":true,"path":"2019/12/01/JavaScript语言编程核心(一)—对象/","link":"","permalink":"https://kmbk0.top/2019/12/01/JavaScript语言编程核心(一)—对象/","excerpt":"","text":"JavaScript语言编程核心（一）— 对象对象这是系列关于js语言核心思想的一些理解，包括对象、继承、原型链、构造函数、执行上下文堆栈、执行上下文、变量对象、活动对象、作用域链、闭包以及this。 本文参考自《JavaScript权威指南》、《JavaScript语言精粹》以及前端早读君的文章《javaScript核心》。 对象在JavaScript中，对象是指可变的键控集合。属性名为字符串，值可以为任何类型的javascript值，每个属性都是一个名/值对。除了可以拥有属性外，对象还可以从一个称为原型的对象中继承属性。这就是JavaScript中的 “原型式继承”。 1、属性特性：在ES5中，属性还包括了一些标识可写、可枚举和可配置的特性。可以通过这些API给原型对象添加方法，并设置成不可枚举，让它们更像内置方法，也可以给对象定义不能修改或删除的属性，“锁定”该对象。获取和定义可使用 getOwnPropertyDescriptor 和 defineProperty 方法：123456789var o = &#123;&#125;;Object.defineProperty(o,&quot;x&quot;,&#123; value:2, writable:true, // 可写性； enumerable:false, // 可枚举性； configurable:true // 可配置性;&#125;);console.log(Object.getOwnPropertyDescriptor(o,&quot;x&quot;));console.log(o.x); 可写，表明是否可以设置改属性的值； 可枚举，表明是否可以通过for/in循环返回； 可配置，表明是否可以删除或修改该属性； 2、对象特性： 对象的原型属性（prototype）通过隐含的__proto__属性指向另一个对象，可以继承原型对象的属性；12Object.getPrototypeOf( ) // 可查询对象的原型；p.isPrototypeOf(o) // 来检测p是否是o的原型； 对象的类（class）是一个表示对象类型的字符串，用以表示对象的类型信息，一般用toString( )来获取：[Object class]。下面是封装好的 classof函数，用来检测对象类型；12345function classof(o)&#123; if(o === null)&#123;return &quot;Null&quot;&#125;; if(o === undefined)&#123;return &quot;Undefined&quot;&#125;; return Object.ptototype.toString.call(o).slice(8,-1);&#125; 对象的扩展标记（extensible flag）指明了是否可以向该对象添加新属性；ES5中，所有的内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是依据引擎所定义的；123456Object.esExtensible( ); // 判断对象是否可扩展；Object.preventExtensions( ); // 将对象设置为不可拓展并且无法再转换回可拓展；但同样可以继承属性；Object.seal( ); // 封闭对象；将对象设置为不可拓展，而且将所有自有属性设置为不可配置；Object.isSealed( ); // 检测对象是否被封闭；Object.freeze( ); // 更严格的冻结对象，不可拓展，配置，且只读；Object.isFrozen( ); // 检测对象是否被冻结； 3、对象的分类： 内置对象：JS内部定义的对象或类，如数组（Array）、函数（Function）、日期（Date）和正则表达式（RegExp）等； 宿主对象：由js解释器所嵌入的宿主环境中定义的对象，如浏览器客户端； 自定义对象：在JS代码中创建的对象； 4、对象属性的分类： 自有属性：在对象内部定义的属性； 继承属性：从原型对象中继承得到的属性； 5、 对象的创建： 对象字面量法：一个对象字面量就是包围在一对花括号中的若干个名/值对组成的映射表，名与值之间用:分隔，名值对间用,分隔。该方法的__proto__指向Object.prototype.12345// 注意，最后一个名/值对后不再添加逗号；var student = &#123; &quot;name&quot;:&quot;Tayde&quot;, &quot;age&quot;:26&#125; new操作符+构造函数：通过new操作符后跟一个函数，初始化创建出一个新的对象，该方法的__proto__指向构造函数.prototype。1var o = new Object(); // 与 var o = &#123; &#125;效果一样； ES5中的Object.create( ):该方法可填两个参数，第一个填对象原型，第二选填自定义的属性；__proto__指向函数中填入的对象。1var o1 = Object.create(&#123;x:1,y:2&#125;); // 则o1对象已经继承了x,y属性； 6、对象属性的查询和设置： .运算符，当属性名为一个简单的标识符时，一个静态值时使用；优先考虑，因为它有更好的可读性； [ ]运算符，该方法更全面，当属性名为变量或动态值时使用；12var name = student.name; var age = student[&quot;age&quot;]; Tips:1、当属性不存在时，会返回 undefined，并不会报错；2、但当查询属性的对象不存在时，则会报错；解决方法：1var len = book &amp;&amp; book.subtitle &amp;&amp; book.subtitle.length; 3、可以用 ||运算符来填充默认值；1var sex = student.sex || &quot;unknown&quot;; 7、对象的引用：对象通过引用来传递，他们永远不会被复制。对象并没有被复制，而是仅仅将x,y指向同一个对象的引用而已。1234var x = &#123;a:1&#125;;var y = x;y.a = 2;console.log(x.a); // 2; 8、对象属性的删除：12delete student.name;delete student[&quot;age&quot;]; Tips：delete操作符只能删除自身属性，无法删除原型上的继承属性；delete操作符值是断开属性和宿主对象的联系，并不是删除属性，因此外部的引用仍会存在；12345var a = &#123;x:&#123;y:1&#125;&#125;;var b = a.x;delete a.x;console.log(b); // &#123;y:1&#125;;console.log(a.x); // undefined; 9、检测属性与对象的从属关系： 1、in运算符：12var o =&#123;x:1&#125;;console.log(&quot;y&quot; in o); // false; 2、hasOwnProperty( )：检测是否为自有属性，如果是继承属性，则返回false；123var o = &#123;x:1&#125;;console.log(o.hasOwnProperty(&quot;x&quot;)); // true;console.log(o.hasOwnProperty(&quot;toString&quot;)); // false; 3、propertyIsEnumerable( ): 属于hasOwnProperty的增强版，只有当属性为自有属性且可枚举性时，才返回true;1234var o = &#123;x:1&#125;;console.log(o.propertyIsEnumerable(&quot;x&quot;)); // true;console.log(o.hasOwnProperty(&quot;y&quot;)); // false;console.log(o.hasOwnProperty(&quot;toString&quot;)); // false; 4、直接与undefined比较；123var o = &#123;x:1&#125;;o.x !== undefined; // true;o.y !== undefined; // false; 10、对象属性的getter和setter:在ES5中，对象的属性值可以用一个或两个方法替代，他们就是getter和setter。由这两个方法定义的属性称作“存取器属性”。123456789var serialnum = &#123; &quot;$n&quot;:0, get next()&#123; return this.$n++; &#125;, set next()&#123; if(n&gt;=this.$n)&#123;this.$n = n;&#125;else&#123;throw &quot;新值必须大于当前值。&quot;&#125; &#125;&#125; 11、序列化对象：对象序列化是指将对象的状态转换成字符串，也可以将字符串转换为对象。使用ES5中的 JSON.stringify( ) 和 JSON.parse( )。 1、NaN、Infinity和-Infinity序列化后的结果是Null;2、函数、RegExp、Error对象和undefined值不能序列化和还原；3、JSON.stringify( ) 只能序列化对象可枚举的自有属性； 12、对象方法： 1、toString( )：无需参数，返回一个该对象的字符串。2、toLocaleString( )：返回一个表示这个对象的本地化字符串。3、toJSON( )：4、valueOf( ):","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kmbk0.top/blog/tags/JavaScript/"}]},{"title":"Gulp简要入门笔记","slug":"Gulp简要入门笔记","date":"2019-11-23T01:01:35.000Z","updated":"2020-01-14T13:57:18.702Z","comments":true,"path":"2019/11/23/Gulp简要入门笔记/","link":"","permalink":"https://kmbk0.top/2019/11/23/Gulp简要入门笔记/","excerpt":"","text":"Gulp简要入门笔记gulp:是一款基于node的前端自动化构建工具，它可以工程化完成许多重复性的各种文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件改动后重复这些步骤。因为这些过程其实是有规律可循，因此我们可以通过构建工具来帮助我们快速地自动化重复执行。 流的思想：gulp使用了node中的流((stream))管道思想，使数据像流水一样通过管道进行输出与输入，管道便是 .pipe( )，使用内存来过渡，而不是像grunt那样直接使用硬盘的直接写入，因此拥有更优秀的性能。 简要工作流程： 1、使用gulp.src( )找到目录下的 .js/css/sass等各种需要处理的 文件流； 2、通过gulp.pipe( )将文件流导入到各种插件中进行处理； 3、再次通过gulp.pipe( )将流传给gulp.dest( ),该指令可以将数据流写入到相应的目录文件中； 1、gulp的安装；由于gulp依赖于node，因此在安装gulp之前需要先安装node;然安装之前可以先在终端中输入node -v用于确定环境是否已经安装node了。安装node可以通过直接在官网下载pkg安装包，https://nodejs.org; 安装完node后，会自带安装其包管理器npm，我们便可以通过它来进行gulp的安装了。 直接在终端中输入：npm install -g gulp ； 全局安装完gulp后，还需要在每个项目中单独安装，终端中进入到项目目录，执行终端命令：1npm install gulp 如果想创建时直接写入package.json，是使用：1npm install --save-dev gulp 2、gulp API学习gulp的API十分的简介清晰，常用的主要有：gulp.src()，gulp.pipe(),gulp.task(),gulp.dest(),gulp.watch(),gulp.run(); gulp.src(globs[, options]):globs：字符串或数组，是文件匹配模式，可以通过文件路径来定位文件，获取文件流(stream)，后可以使用pipe管道输入到各种插件中； [options]：对象，可选参数；里面包含多个属性； options.buffer：类型： Boolean 默认值： true 如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read：类型： Boolean 默认值： true 如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base：类型： String 设置基准路径，影响导出文件路径，会使用传入dest()的路径替换掉 原始路径中base部分。如1234567gulp.src(&apos;client/js/**/*.js&apos;) // 匹配 &apos;client/js/somedir/somefile.js&apos; 并且将 `base` 解析为 `client/js/` .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); // 写入 &apos;build/somedir/somefile.js&apos;gulp.src(&apos;client/js/**/*.js&apos;, &#123; base: &apos;client&apos; &#125;) .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); // 写入 &apos;build/js/somedir/somefile.js&apos; gulp.dest(path[, options])：该方法是可以将pipe导入的数据流写入对应的文件中。可以同时写入多个文件；如：12345gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) .pipe(minify()) .pipe(gulp.dest(&apos;./build/minified_templates&apos;)); gulp.task(name[, deps], fn):该方法是用于定义gulp任务；123gulp.task(&apos;taskname&apos;, function() &#123; // 做一些事&#125;); deps：类型：数组 可选参数，可定义一系列任务列表，将会在任务之前执行；123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; // 做一些事&#125;); Tip：列表中的任务将被并行执行； gulp.watch(glob[, opts], tasks):监视文件的变化，如果变化，则执行 tasks任务；1234var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);watcher.on(&apos;change&apos;, function(event) &#123; console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);&#125;); gulp.watch(glob[, opts, cb]):123gulp.watch(&apos;js/**/*.js&apos;, function(event) &#123; console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);&#125;); 总结 gulp API: gulp.task： 表示创建gulp任务； gulp.src：输入的目录，通过 *.js可以匹配到js目录下的所有js文件； gulp.pipe：管道指令，可以理解为加入执行队列； gulp.dest：处理后的文件输出的目录； gulp.watch：实时监控文件改变，一旦改变则马上执行任务； 3、自动加载配置中的插件，gulp-load-plugins；我们可以在项目中为gulp保存一份配置文件：package.json，然后使用gulp-load-plugins这个插件便可以一次性加载配置中保存的所有插件；123var gulp = require(&apos;gulp&apos;);//加载gulp-load-plugins插件，并马上运行它var plugins = require(&apos;gulp-load-plugins&apos;)(); 4、使用gulp进行JS的压缩，gulp-uglify；1、在项目中新建一个gulpfile.js文件，用于写入gulp配置代码； 2、安装gulp-uglify模块，终端输入：npm install --save-dev gulp-uglify; 3、在gulpfile.js中载入gulp模块12// 获取 gulpvar gulp = require(&apos;gulp&apos;); 4、载入gulp-uglify模块：12// 获取 uglify 模块（用于压缩 JS）var uglify = require(&apos;gulp-uglify&apos;); 5、创建gulp任务；123456789// 压缩 js 文件gulp.task(&apos;javascript&apos;, function() &#123; // 1. 找到文件 gulp.src(&apos;js/*.js&apos;) // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest(&apos;dist/js&apos;))&#125;); 6、终端执行，在终端中使用 cd进入到项目目录中，输入命令：gulp javascript;如果得到输出结果为：1234gulp script[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[13:34:57] Starting &apos;script&apos;...[13:34:57] Finished &apos;script&apos; after 6.13 ms 则任务执行成功；在目录的dist/js下，便可以看到已经压缩后的js文件； 5、压缩HTML，gulp-minify-html：使用gulp-minify-html插件用来压缩html文件。任务如下：12345678var gulp = require(&apos;gulp&apos;), minifyHtml = require(&quot;gulp-minify-html&quot;);gulp.task(&apos;minify-html&apos;, function () &#123; gulp.src(&apos;src/*.html&apos;) // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest(&apos;dist/html&apos;));&#125;); 6、压缩CSS，gulp-minify-css：使用gulp-minify-css插件用来压缩css文件，任务如下：12345678var gulp = require(&apos;gulp&apos;), minifyCss = require(&quot;gulp-minify-css&quot;);gulp.task(&apos;minify-css&apos;, function () &#123; gulp.src(&apos;src/*.css&apos;) // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); 7、压缩图片，gulp-imagemin；1234567891011var gulp = require(&apos;gulp&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);var pngquant = require(&apos;imagemin-pngquant&apos;); //png图片压缩插件gulp.task(&apos;default&apos;, function () &#123; return gulp.src(&apos;src/images/*&apos;) .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest(&apos;dist&apos;));&#125;); 8、文件的重命名，gulp-rename；gulp会以输入的文件流的名称来命名处理后的文件名，因此，如果需要重命名文件时，可以使用 gulp-rename插件；12345678910var gulp = require(&apos;gulp&apos;), rename = require(&apos;gulp-rename&apos;), uglify = require(&quot;gulp-uglify&quot;);gulp.task(&apos;rename&apos;, function () &#123; gulp.src(&apos;src/1.js&apos;) .pipe(uglify()) //压缩 .pipe(rename(&apos;1.min.js&apos;)) //会将1.js重命名为1.min.js .pipe(gulp.dest(&apos;js&apos;));&#125;); 9、JS代码检查，使用 gulp-jshint；12345678var gulp = require(&apos;gulp&apos;), jshint = require(&quot;gulp-jshint&quot;);gulp.task(&apos;jsLint&apos;, function () &#123; gulp.src(&apos;src/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 10、文件的合并，gulp-concat；1234567var gulp = require(&apos;gulp&apos;), concat = require(&quot;gulp-concat&quot;);gulp.task(&apos;concat&apos;, function () &#123; gulp.src(&apos;src/*.js&apos;) //要合并的文件 .pipe(concat(&apos;all.js&apos;)) // 合并匹配到的js文件并命名为 &quot;all.js&quot; .pipe(gulp.dest(&apos;dist/js&apos;));&#125;); 11、自动刷新，实时反馈代码的改变，gulp-livereload；12345678910111213var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;), livereload = require(&apos;gulp-livereload&apos;);gulp.task(&apos;less&apos;, function() &#123; gulp.src(&apos;less/*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;css&apos;)) .pipe(livereload());&#125;);gulp.task(&apos;watch&apos;, function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch(&apos;less/*.less&apos;, [&apos;less&apos;]);&#125;); 该笔记参考于 Nimo Chu的github与前端乱炖社区文章《学习前端自动化构建工具Gulp》以及gulp官方文档；","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"},{"name":"笔记","slug":"教程/笔记","permalink":"https://kmbk0.top/blog/categories/教程/笔记/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"https://kmbk0.top/blog/tags/Gulp/"}]},{"title":"HTML学习笔记","slug":"HTML学习笔记","date":"2019-11-21T01:01:35.000Z","updated":"2020-01-14T12:49:47.568Z","comments":true,"path":"2019/11/21/HTML学习笔记/","link":"","permalink":"https://kmbk0.top/2019/11/21/HTML学习笔记/","excerpt":"","text":"HTML学习笔记一、发展史：二、文档：12345&lt;!DOCTYPE html&gt; // 以H5解析文档；&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 文档头部内容：12345678910111213141516&lt;head&gt; // 定义文档编码类型； &lt;meta charset = &quot;utf-8&quot; /&gt; &lt;title&gt;网页标题&lt;/title&gt; // 描述网页的基本信息，有利于SEO； &lt;meta name = &quot;keywords&quot; concent = &quot;...&quot; /&gt; &lt;meta name = &quot;description&quot; content = &quot;...&quot; /&gt; // 移动端使用，定义viewport; &lt;meta name = &quot;viewport&quot; content = &quot;width = device-width&quot; /&gt; // 定义标题前的图标，网页的icon； &lt;link rel = &quot;shortCut icon&quot; href = &quot;***.ico&quot; /&gt; // 外联CSS样式； &lt;link rel = &quot;stylesheet&quot; href = &quot;***.css&quot; /&gt; // 内联样式； &lt;style&gt;&lt;/style&gt;&lt;/head&gt; 文档主体：语法： 小写、属性双引号、嵌套缩进；常用属性：id/class/style/title （每个标签都有）；三、标签：1、文档章节：1&lt;body&gt;/&lt;header&gt;/&lt;nav&gt;/&lt;aside&gt;/&lt;article&gt;/&lt;section&gt;/&lt;footer&gt;/&lt;hx&gt; 2、文本内容：超链接：1`&lt;a href = &quot;http://....&quot; target = &quot;_self/_blank/inner&quot;&gt;&lt;/a&gt;` href中直接填入文件，则为下载； href中填入“#pay”，则为跳转到id = ”pay“的页面锚点； href中填入 “mailto: wjb0@vip.qq.com” ，则可以直接链接到email； href中填入“tel:111111111”，可链接到tel； 强调： &lt;em&gt;斜体&lt;/em&gt; &lt;strong&gt;粗体&lt;/strong&gt;区分样式： &lt;span&gt;span&lt;/span&gt;换行： &lt;br/&gt;引用： &lt;cite&gt;引用&lt;/cite&gt; &lt;q&gt;引用&lt;/q&gt; &lt;blockquote&gt;块状引用&lt;/blockquote&gt;代码： &lt;code&gt;代码&lt;/code&gt;格式化： &lt;b&gt;&lt;/b&gt; &lt;i&gt;&lt;/i&gt;块： &lt;div&gt;块&lt;/div&gt;段落：&lt;p&gt;段落&lt;/p&gt;列表：123456789101112131415161718// 无序列表； &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt;&lt;/ul&gt;// 有序列表； &lt;ol type = &quot;a&quot; start = &quot;2&quot;&gt; &lt;li&gt;冠军&lt;/li&gt; &lt;li&gt;亚军&lt;/li&gt; &lt;li&gt;季军&lt;/li&gt;&lt;/ol&gt;// 定义列表；&lt;dl&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 将特殊符号转义成实体字符：&lt;pre&gt;&gt;&lt;/pre&gt;图片：1&lt;img src = &quot;&quot; alt = &quot;&quot; /&gt; 外部资源嵌入：1234567// 可嵌入多种对象；&lt;object type = &quot;&quot;&gt; &lt;param name = &quot;&quot; value = &quot;&quot; /&gt;&lt;/object&gt;// 嵌入多种多媒体内容；&lt;embed type = &quot; &quot; src = &quot; &quot; width=&quot;&quot; height=&quot;&quot; /&gt; 视频：12345678// 自动播放 循环 控制器 封面&lt;video auto loop controls poster=&quot;&quot;&gt; // 视频资源 &lt;source src=&quot; &quot; type=&quot;&quot; /&gt; &lt;source src=&quot; &quot; type=&quot;&quot; /&gt; // 引入字幕； &lt;track kind=&quot;subtitles&quot; src=&quot;&quot; srclang=&quot;cn&quot; label=&quot;cn&quot; /&gt;&lt;/video&gt; 音频：（与video一致）123&lt;audio&gt; &lt;source src=&quot;&quot;&gt;&lt;/audio&gt; 图形图像：&lt;canvas&gt; &lt;svg&gt;热点区域：123456&lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; usemap=&quot;#Map&quot;&gt;// map标签中的name属性与img标签中的usemap一致；&lt;map name=&quot;Map&quot; data-ganame=&quot;&quot; data-gapoint=&quot;&quot;&gt; // 热点区域 形状 坐标 链接 打开方式 &lt;area shape=&quot;rect&quot; coords=&quot;&quot; href=&quot;&quot; target=&quot;&quot; /&gt;&lt;/map&gt; 表格：123456789101112131415161718&lt;table&gt; &lt;caption&gt;标题&lt;/caption&gt; // 表头 &lt;thead&gt; // 跨2列 &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;表头&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; // 跨2行 &lt;th rowspan=&quot;2&quot;&gt;行头&lt;/th&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 表单：1234567891011121314151617181920212223242526272829303132// 提交到文件 提交方式&lt;form action=&quot;/login.php&quot; method=&quot;post&quot;&gt; // 分区 &lt;fieldset&gt; &lt;legend&gt;区域标题&lt;/legend&gt; &lt;label for=&quot;&quot; /&gt; &lt;/fieldset&gt; // 上传文件 &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; // 单选框 &lt;input type=&quot;checkbox&quot; name=&quot;size&quot; value=&quot;5&quot; /&gt; // 多选框 &lt;input type=&quot;radio&quot; name=&quot;material&quot; value=&quot;5&quot; /&gt; // 文本输入 &lt;input type=&quot;text&quot; name=&quot;description&quot; placeholder=&quot;提示&quot; value=&quot;初始化内容&quot; /&gt; // 提交，重置按钮 &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; // 下拉选择框 &lt;label for=&quot;delivery&quot;&gt;配送方式:&lt;/label&gt; &lt;select id=&quot;delivery&quot;&gt; // 选项组 &lt;optgroup label=&quot;组标题&quot;&gt; // 默认选中 &lt;option value=&quot;0&quot; selected&gt;快递&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;面取&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; // 多行文本框 &lt;textarea name=&quot;text&quot; rows=&quot;4&quot; id=&quot;&quot;&gt;&lt;/textarea&gt; HTML5新命令：input标签的type属性 = email/url/number/tel/search/range/color/data picker…. 实体字符转义： 空格 ===&gt;&amp;nbsp;&quot; ===&gt; &amp;quot;&gt; ===&gt; &amp;gt;&lt; ===&gt; &amp;lt;@===&gt; &amp;copy;&amp;===&gt; &amp;amp;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"},{"name":"笔记","slug":"教程/笔记","permalink":"https://kmbk0.top/blog/categories/教程/笔记/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://kmbk0.top/blog/tags/html5/"}]},{"title":"Mac终端常用命令","slug":"Mac终端常用命令","date":"2019-11-15T08:21:00.000Z","updated":"2020-01-14T12:52:37.619Z","comments":true,"path":"2019/11/15/Mac终端常用命令/","link":"","permalink":"https://kmbk0.top/2019/11/15/Mac终端常用命令/","excerpt":"","text":"Mac终端常用命令获取系统最高权限 ：sudo -s； 清理系统，也就是执行系统自带的清理脚本：1sudo periodic daily; sudo periodic weekly; 1sudo periodic monthly; 列出文件列表：ls; 切换目录： cd+ 路径; 建立新文件：cd filename; 拷贝文件：cp -R /User/用户名/a /User/用户名/b/; 移动文件：mv -R /User/用户名/a /User/用户名/b/; 删除文件：rm; 更改文件权限：chmod;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"},{"name":"终端","slug":"教程/终端","permalink":"https://kmbk0.top/blog/categories/教程/终端/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://kmbk0.top/blog/tags/Mac/"}]},{"title":"web worker简易入门","slug":"web-worker-learning","date":"2019-11-11T10:01:35.000Z","updated":"2020-01-14T10:58:26.881Z","comments":true,"path":"2019/11/11/web-worker-learning/","link":"","permalink":"https://kmbk0.top/2019/11/11/web-worker-learning/","excerpt":"","text":"js是单线程的语言，由于此特性，我们在处理并发时需要用到一些技巧，如setTimeout()，setInterval()，调用XMLHttpRequest等。但这里的并发只是非阻塞（参照John Resig的文章How JavaScript Timers Work），真正的多线程编程则需要HTML5的web worker。 【worker的使用】web worker的使用非常简单，线程之间通讯的api与html5 postmessage或node.js里面的socket.io方法类似。 通讯： 发送方：postMessage(data) 接收方：onmessage(event) 终止web worker: 子线程: self.close() 父线程: worker.terminate() 按照目前w3c规范，web worker分为两种：专用worker(Dedicated Worker)和共享worker(Shared Worker)。 【专用worker】实例化一个web worker对象，异步加载子线程文件worker.js，其中的代码将执行。1var worker = new Worker(&quot;worker.js&quot;); 给worker增加侦听123worker.onmessage = function (event) &#123; alert(event.data);&#125;; 在worker.js里，发送消息给父线程1postMessage(&apos;hello，imweb&apos;); 在父线程页面就能看到发送过来的信息了。 同时，在web worker标准中，是支持对象参数的，也就是说我们能够传递json数据。再看一个稍微复杂点的例子，父线程：123456789101112131415161718192021222324252627282930313233343536373839404142 var worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function (event) &#123; document.getElementById(&quot;result&quot;).innerHTML=event.data; &#125;; function start()&#123; worker.postMessage(&#123;&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;&#125;); &#125; function pause()&#123; worker.postMessage(&#123;&apos;cmd&apos;: &apos;pause&apos;, &apos;msg&apos;: &apos;pause&apos;&#125;); &#125; function stop()&#123; worker.postMessage(&#123;&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;stop&apos;&#125;); &#125; function msg()&#123; worker.postMessage(&#123;&apos;msg&apos;: &apos;hello imweb&apos;&#125;); &#125;worker.js： self.onmessage = function (e) &#123; var data = e.data; switch (data.cmd) &#123; case &apos;start&apos;: taskStart(); //大量数据处理 postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;pause&apos;: taskPause(); postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;stop&apos;: postMessage(&apos;WORKER DO: &apos; + data.msg); self.close(); //终止web worker break; default: postMessage(&apos;MESSAGE: &apos; + data.msg); &#125;; &#125;; 从上面的例子可以看到，一是利用对象参数，进程之间能够较灵活的实现控制；二是当woker执行taskStart()处理大量数据时，只在子进程处理，不会给主页面带来阻塞，通常，处理大量数据会消极影响程序的响应能力，而web worker通过这样的方式，能提供一个更流畅更实时的UI。 【共享worker】共享worker允许线程在同源中的多个页面间进行共享，例如：同源中所有页面或脚本可以与同一个共享线程通信。它的实例化与事件侦听的写法与专用worker略有不同,主页面：1234567891011121314151617181920212223242526 var worker = new SharedWorker(&apos;shared-worker.js&apos;); worker.port.onmessage = function(e) &#123; msg = &apos;Someone just said &quot;&apos; + e.data.message + &apos;&quot;. That is message number &apos; + e.data.counter; console.log(msg); &#125;; worker.port.postMessage(&apos;hello shared worker!&apos;);shared-worker.js: var counter = 0; var connections = []; onconnect = function(eConn) &#123; var port = eConn.ports[0]; // 此连接的特有port //当有消息的时候通知所有的连接 port.onmessage = function(eMsg) &#123; counter++; for (var i=0; i &lt; connections.length; i++) &#123; connections[i].postMessage(&#123; message: eMsg.data, counter: counter &#125;); &#125; &#125; port.start(); connections.push(port); 用两个窗口打开这个页面，第一个显示：Someone just said “Hello shared worker!” This is message number 1，第二个也收到一样的信息，但是后面是message number 2。 【安全性和错误检查】出于安全性的考虑，web worker必须遵守同源策略。同时，它的全局对象是worker对象本身，this和self引用的都是worker对象。只能访问： navigator 对象（仅限appName, appVersion, platform, userAgent） location 对象（只读） XMLHttpRequest setTimeout(), setInterval(), clearTimeout()和clearInterval()方法 不能访问： DOM(不是线程安全的) window 对象 document 对象 parent 对象 worker内部出现错误时，可以用worker.onerror侦听到，error的事件有三个属性： filename: 发生错误的文件名 lineno: 代码行号 message: 完整的错误信息 如：123worker.onerror = function(e) &#123; console.log(e.filename+&quot;ERROR on line&quot;+e.lineno+&quot;,msg:&quot;+e.message);&#125; 【web worker的其他尝试】对于比较消耗时间的操作，我们可看到web worker能够发挥它的作用。比如：大量数据排序，精确到像素的canvas计算等。而我们又知道，jsonp加载数据时，动态创建script标签，加载和执行这些过程都是阻塞式的，而web worker正好可以异步加载，这会是更快的方式吗？带着这个疑问我做了下面的试验，分别用jsonp和worker的方式去加载文件，计算数据返回时延：1234567891011121314151617181920function tryJsonp()&#123; var d = (new Date()).valueOf(); var jsonp=document.createElement(&quot;script&quot;); jsonp.type=&quot;text/javascript&quot;; jsonp.src=&quot;worker.js?_=&quot;+d; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonp); jsonp.onload = jsonp.onreadystatechange = function()&#123; if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;)&#123; console.log(&apos;jsonp: &apos;+ ((new Date()).valueOf() - d)); &#125; &#125;&#125;function tryWorker()&#123; var d = (new Date()).valueOf(); var worker = new Worker(&quot;worker.js&quot;); worker.postMessage(&#123;&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;&#125;); worker.onmessage = function (event) &#123; console.log(&apos;web worker: &apos;+ ((new Date()).valueOf() - d)); &#125;;&#125; 对于较小的数据，jsonp还是比web worker要快，这可能是实例化worker对象时带来的影响；而数据偏大时，web worker的加载将会更优，而且它可以异步加载。 THE END.","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://kmbk0.top/blog/tags/html5/"},{"name":"web","slug":"web","permalink":"https://kmbk0.top/blog/tags/web/"}]},{"title":"CSS学习笔记","slug":"CSS学习笔记","date":"2019-09-21T11:01:35.000Z","updated":"2020-01-14T12:45:01.997Z","comments":true,"path":"2019/09/21/CSS学习笔记/","link":"","permalink":"https://kmbk0.top/2019/09/21/CSS学习笔记/","excerpt":"","text":"CSS学习笔记引入： 外部样式： 1&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; 内部样式表： 123&lt;head&gt; &lt;style&gt;...&lt;style&gt;&lt;/head&gt; 内嵌样式： 1&lt;p style=&quot;color:red;margin-left:20px&quot;&gt;&lt;/p&gt; 注释：1/* 我是注释；*/ 浏览器私有属性： chrome、safari: -webkit-;firefox: -moz-;IE:-ms-;opera: -o-; 语法规则：123456margin:[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,4&#125;/* &lt;length&gt;:基本元素； `|`:组合符号； &#123;1,4&#125;:数量符号；*/ 基本元素：1、关键字： auto、solid、bold……2、组合符号： 空格：表示必须出现，且顺去固定； &amp;&amp;：必须出现，但顺序不固定； ||：至少出现一个，但顺序随意； |：只能出现一个； []：分组； +：可出现一次或多次； ？：可出现也可不出现； {}：可以出现的次数；{2，4}：最少出现2次，最多出现4此； *：可出现0次，1次或多次； #：需出现1次或多次，需要用,隔开； 规则语法： @media：响应式布局时监听屏幕尺寸； @keyframs：描述CSS动画帧； @font-face：引入外部字体； @import/@charset/@name space/@page/@supports/@document 选择器：简单选择器：12345678910标签选择器： tag&#123; &#125;类选择器：.className&#123; &#125;id选择器： #id&#123; &#125;通配符： *&#123; &#125;属性选择器： [disabled]&#123; &#125;/[type=button]&#123; &#125; [class~=&quot;sports&quot;]&#123; &#125; // 类名中包含sports,且以空格隔开； [lang|=&quot;en&quot;]&#123; &#125; // 类名中包含en，且以“-”隔开； [href^=&quot;#&quot;]&#123; &#125; // href属性值以 # 开头的元素； [href$=&quot;pdf&quot;]&#123; &#125; // href属性值以 pdf 结尾的元素； [here*=&quot;lady&quot;]&#123; &#125; // href属性值包含lady的元素； 伪类选择器：1234567891011121314151617181920a:link&#123; &#125; // 选中具有href的a标签样式；a:visited&#123; &#125; // 已访问过的链接的样式；a:hover&#123; &#125; // 当鼠标移上时的样式；a:active&#123; &#125; // 当鼠标点击时的样式；:enabled&#123; &#125; :disabled&#123; &#125; :chedcked&#123; &#125;li:first-child&#123; &#125; li:last-child&#123; &#125; // 元素首项、末项li:nth-child(even)&#123; &#125; // 选中偶数项li:nth-child(3n+1)&#123; &#125; // 选中正序第1、4、7。。。项li:nth-last-child(3n+1)&#123; &#125; // 选中倒序第1、4、7。。。项li:only-child&#123; &#125; // 选中作为唯一子元素的的li标签dd:first-of-type&#123; &#125; // 选中第一个dd类型的元素dd:last-of-type&#123; &#125; // 选中最后一个；dd:nth-of-type&#123; &#125; span:only-of-type&#123; &#125; // 选中同级元素只有一个span的&lt;span&gt;:empty&#123; &#125; :root&#123; &#125; :not()&#123; &#125; :target()&#123; &#125; // 选择器会突出显示当前活动的HTML锚; 组合选择器： 可以将简单选择器进行组合，如 img[src$=”jpg”]{ }; 伪元素选择器：1234567::first-letter&#123; &#125;; /* 选择头字母；*/::first-line&#123; &#125;; /* 选择首行；*//* 插入内容；*/::before&#123;content:&quot;before&quot;;&#125;::after&#123;content:&quot;after&quot;;&#125; /* 应用于被用户选中的内容 */::selection&#123; &#125; 后代选择器：12345678910&lt;div class=&quot;main&quot;&gt; &lt;h2&gt;111&lt;/h2&gt; &lt;div&gt; &lt;h2&gt;222&lt;/h2&gt; &lt;p&gt;333&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;.main h2&#123; &#125; // 选中111、222;.main&gt;h2&#123; &#125; // 选中111 兄弟选择器：12345678&lt;div class=&quot;main&quot;&gt; &lt;h2&gt;111&lt;/h2&gt; &lt;p&gt;222&lt;/p&gt; &lt;p&gt;333&lt;/p&gt;&lt;/div&gt;h2+p&#123; &#125; // 选中与h2相邻的p：222；h2~p&#123; &#125; // 选中h2同级之后的所有p:222,333; 选择器分组： 可以使用 ,讲选择器合并：1h1,h2,h3&#123; &#125;; CSS选择器优先级： 样式类型 权重 a：行内样式 1000 b：id选择器 100 c：类、伪类和属性选择器 10 d：标签和伪元素选择器 1 value值 = a 1000 + b 100 + c* 10+ d ; 1、当value不等时，value值越大，则优先权更大；不同属性则合并，相同属性覆盖；2、当value相等时，相同属性，后面的覆盖前面；不同属性合并； 改变CSS优先级：1、通过改变CSS里的前后顺序；2、提升选择器的value值；3、加入 !important. （优先使用1、2）； 文本与颜色：字体大小1font-size:&lt;length&gt;|&lt;percentage&gt;|&lt;absolute-size&gt;|&lt;relative-size&gt; &lt;length&gt;: 例如14px;&lt;percentage&gt;: 例如200%/2em(2em/200% ：表示为父级字体大小的2倍)；&lt;absolute-size&gt;:例如small、large;&lt;relative-size&gt;: 例如smaller、larger; 字体1font-family:[&lt;family-name&gt;|&lt;generic-family&gt;]# 字体族名称(family-name)：是具体的字体名称, “Microsoft YaHei” 类族名称(generic-family)：是字体类型名称而具体的字体则由浏览器决定,serif/sans-serif/cursive/fantasy/monospace等 font-family中设置的字体不会被浏览器自动下载, 字体是否可用则完全依靠用户电脑是否已安装该字体库而已； 属性值必须以类族名称(generic-family)结尾确保字体会以正确的形式解析渲染； 类族名称(generic-family)后的字体族名称(family-name)不会生效; 字体粗细；1font-weight:normal|bold|bolder|lighter|100|200... 斜体；1font-style:normal|italic|oblique 行高；1line-height:normal|&lt;number&gt;|&lt;length&gt;|&lt;percentage&gt; 设置linge-height:300%与设置line-height:3的区别： line-height：两行基线的间隔；设置为300%时，直接以父元素的字体大小计算后继承，不管子元素自身的字体大小；既为父元素字体大小的3倍；（先计算后继承，为静态值）设置为3时，则是动态的根据子元素自身的字体大小乘以3；（先继承后计算，为动态值，会自适应）； 利用line-height让多行文本垂直居中：在文本的后面添加个空白元素，设置其line-height和父元素高度一致，并在文本上设置vertical-align:middle; 字体组合样式：12// font:italic bolid 20px/1.5 arial,serif;font:[&lt;font-style&gt;||&lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt; 字体颜色：1234color:red;color:#ff0000;color:rgb(255,0,0);color:rgba(255.0.0.1) 对齐：水平对齐：左对齐/右对齐/居中/两端对齐1text-align:left|right|center|justify 垂直对齐：1vertical-align:baseline|sub|super|top|text-top|middle|bottom|text-bottom|&lt;percentage&gt;|&lt;length&gt; 文本缩进：1text-indent:&lt;length&gt;|&lt;pencentage&gt; 换行，空格，自动换行：1white-space:normal|nowrap|pre|pre-wrap|pre-line normal： 换行符、空格合并，自动换行；nowrap：换行符、空格合并，不自动换行；pre：换行符、空格保留，不自动换行；pre-wrap：换行符、空格保留，自动换行；pre-line：换行符保留、空格/tab合并，自动换行； 单词换行：12word-wrap:normal|break-word;word-break:normal|keep-all|break-all; 文字阴影：12text-shadow:none|[&lt;length&gt;&#123;2,3&#125;&amp;&amp;&lt;color&gt;?]#;text-decoration:none|[underline||overline||line-through]; 隐藏文本，且用省略号显示：123text-overflow:ellipsis;overflow:hidden;white-space:nowrap; 定义鼠标形状：12// 自定义|自适应|鼠标|消失|疑问|点击|放大|缩小|移动cursor:[&lt;url&gt;]*,[auto|default|none|help|pointer|zoom-in|zoom-out|move]; 强制继承： inherit;盒模型：12345678// min-width,max-width用法一致；width:&lt;length&gt;|&lt;percentage&gt;|auto|inherit;// min-width,max-width用法一致；height:&lt;length&gt;|&lt;percentage&gt;|auto|inherit;// 顺序为 上，右，下，左padding:[&lt;length&gt;|&lt;percentage&gt;]&#123;1,4&#125;;margin:[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,4&#125;; ​ 边框：12345border:[&lt;border-width&gt;||&lt;border-style&gt;||&lt;border-color&gt;];border-width:[&lt;length&gt;]&#123;1,4&#125;;// 实线|虚线|点border-style:[solid|dashed|dotted]&#123;1,4&#125;;border-color:[&lt;color&gt;|transparent]&#123;1,4&#125;; 圆角边框：1234border-radius:[&lt;length&gt;|&lt;percentage&gt;]&#123;1,4&#125;[/[&lt;length&gt;|&lt;pencentage&gt;]&#123;1,4&#125;]?// 水平半径 / 垂直半径border-radius: 0px 5px 10px 15px/20px 15px 10px 5px;border-top-left-radius:5px; # 设置超出部分的样式：123// overflow-x|overflow-y;// 可见|隐藏|出现滚动条|自动显隐滚动条；overflow:visible|hidden|scroll|auto; 切换盒子模型模式：1box-sizing:content-box|border-box|inherit; 盒阴影：123456box-shadow:none|&lt;shadow&gt;[,&lt;shadow&gt;]*&lt;shadow&gt;:inset?&amp;&amp;&lt;length&gt;&#123;2,4&#125;&amp;&amp;&lt;color&gt;?//水平偏移 垂直偏移 模糊半径 阴影大小 阴影颜色；box-shadow:4px 6px 3px 3px red;// 内阴影box-shadow:inset 0px 0px 5px red; 轮廓：1234outline:[&lt;out-width&gt;||&lt;outline-style&gt;||&lt;outline-color&gt;];outline-width:&lt;length&gt;;outline-style:solid|dashed|dotted;outline-color:&lt;color&gt;|invert; 与border值较为相似，但有两点区别：1、border占据空间，而outline并不占据空间；2、outline在border的外围； 背景(位于盒模型的最底层)：123background-color:&lt;color&gt;；background-image:&lt;bg-image&gt;[,&lt;bg-image&gt;]*&lt;bg-image&gt; :&lt;image&gt;|none; Tips:1、绝对路径：“http://….”;2、相对路径，相对于根目录，CSS文件是相对于CSS文件，JS文件是相对于HTML的文件，..代表上一级：”../images/x.png”； 背景平铺方式：12345background-repeat:&lt;repeat-style&gt;[,&gt;repeat-style&gt;]*// X方向重复|Y方向重复|重复|留空隙平铺|伸缩铺满&lt;repeat-style&gt;:repeat-x|repeat-y|[repeat|space|round|no-repeat]&#123;1,2&#125;;// x轴不重复，y轴重复background-repeat:no-repeat repeat; 背景固定方式：123background-attachment:&lt;attachment&gt;[,&lt;attachment&gt;]*// 背景随滚动而滚动|背景固定|继承&lt;attachment&gt;:scroll|fixed|inherit; 背景图片位置：12background-position:&lt;position&gt;[,&lt;position&gt;]*&lt;position&gt;:left|center|right|top|bottom|&lt;percentage&gt;|&lt;length&gt; background-position:10px 20px; 表示x轴偏移10px,y轴偏移20px；background-position:20% 50%; 表示相对于父元素的定位；background-position: center center; 图片居中；background-position:right; 水平靠右，垂直居中；background-position:right 10px top 20px; 与右边偏10px ,与上边偏20px； 常用的背景属性：1background:url(&quot;x.png&quot;) no-repeat 10px 10px; 设置背景参照盒子：12background-origin:&lt;box&gt;[,&lt;box&gt;]*&lt;box&gt;:border-box|padding-box|concent-box; 设置背景平铺的范围：12background-clip:&lt;box&gt;[,&lt;box&gt;]*&lt;box&gt;:border-box|padding-box|concent-box; 改变背景图片的大小：12background-size:&lt;bg-size&gt;[,&lt;bg-size&gt;]*;&lt;bg-size&gt;:[&lt;length&gt;|&lt;percentage&gt;|auto]&#123;1,2&#125;|cover|contain; 组合：123background:[&lt;bg-image&gt;||&lt;position&gt;[/&lt;bg-size&gt;]?||&lt;repeat-style&gt;||&lt;attachment&gt;||&lt;box&gt;||&lt;box&gt;]*&lt;bg-layer&gt;||&lt;background-color&gt;background:url(&quot;red.png&quot;) 0 0/20px 20px no-repeat,url(&quot;blue.png&quot;) 50% 50%/contain no-repeat content-box green; 背景的线性渐变：123456789linear-gradient( ); [[&lt;angle&gt;|to &lt;side-or-corner&gt;],]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+; &lt;side-or-corner&gt;:[left|right]||[top|bottom]; &lt;color-stop&gt;:&lt;color&gt;[&lt;percentage&gt;|&lt;length&gt;]?background-image:linear-gradient(red,blue);background-image:linear-gradient(to top right,red,blue);background-image:linear-gradient(45deg,red,blue);background-image:linear-gradient(red,green 20%,blue); 背景的径向渐变：12345background-image:radial-gradient(closest-side,red,blue);background-image:radial-gradient(circle,red,blue);background-image:radial-gradient(circle 100px,red,blue);background-image:radial-gradient(red,blue);background-image:radial-gradient(100px 50px,red,blue); 重复渐变： background-image:repeating-linear-gradient( ); background-image:repeating-radial-gradient( ); 布局：display:1display:block|inline|inline-block|none; display : block;块级元素，包括&lt;div&gt;&lt;p&gt;&lt;h1&gt;..&lt;h6&gt;&lt;ol&gt;&lt;ul&gt;&lt;dl&gt;&lt;table&gt;&lt;form&gt;…特点：1、占据整行；2、 默认宽度为父元素宽度；3、可设置宽高； display:inline;行内元素，包括&lt;span&gt;&lt;a&gt;&lt;i&gt;&lt;em&gt;&lt;label&gt;&lt;cite&gt;…1、宽度为内容宽度；2、不可设置宽高；3、同行显示； display:inline-block;内联块级元素，包括&lt;input&gt;&lt;img&gt;&lt;textarea&gt;&lt;select&gt;&lt;button&gt;…1、默认宽度为内容宽度；2、可设置宽高；3、同行显示；4、整块换行； display: none;元素不显示，且不占据空间； display: hidden;元素隐藏，但占据空间； 小技巧：12// 块级元素水平居中：.div&#123;margin:0 auto; width:900px;&#125; position1234// 默认定位| 相对定位 | 绝对定位| 固定定位positon:static|relative|absolute|fixed；// 配合属性：top/right/bottom/left/z-index: Tip：1、如果同时设置了top与bottom，且没有设置高度时，则元素会被强制拉伸；如果设置了高，则不拉伸，显示为设定的高度；2、z-index：设置层级，层级高的在顶层，会覆盖住层级低的元素。同时需要考虑父级元素的层级。 position:relative;其主要的用途是元素设置后作为子元素绝对定位的参照物；1、仍处于文档流中；2、参照物为元素本身； position:absolute;绝对定位；1、默认宽度为内容宽度；2、脱离文档流；3、参照物为父级第一个定位元素或者根元素；用途：轮播图，定位…. position:fixed;固定定位；1、默认宽度为内容宽度；2、脱离文档流；3、参照物为窗口；用途：固定顶栏，遮罩… 三行自适应布局：123.head&#123;positon:absolute;top:0;left:0;width:100%;height:100px;&#125;.body&#123;positon:absolute;top:100px;left:0;bottom:100px;right:0;overflow:auto;&#125;.foot&#123;positon:absolute;bottom:0;left:0;width:100%;height:100px;&#125; float:1float:left|right|none|inherit; 1、默认宽度为内容宽度；2、半脱离文档流；脱离元素文档流，但出于内容文档流中；3、想指定方向一直移动；4、设置了float属性的元素在同一文档流中； 清楚浮动的影响：1、空白元素：在浮动元素的后面添加一个空白元素；12&lt;br class=&quot;cf&quot;&gt;.cf&#123;clear:both;height:0;overflow:hidden;visibility:hidden;&#125; 2、claearfix：为设置float属性的元素的父元素添加类名“clearfix”;12.clearfix:after&#123;content:&quot;.&quot;;display:block;clear:both;height:0;overflow:hidden;visibility:hidden;&#125;.clearfix&#123;zoom:1&#125; 弹性flex布局1、创建弹性容器flex container：(父级)123.container&#123; display:flex;&#125; 2、为容器设置成弹性容器后，处于文档流中的直接子元素自动变成弹性元素flex item。弹性元素的横向排列方向为main axis，纵向为cross axis。 排列方向：（弹性容器）12// 横正向| 横逆向 |纵正向 | 纵逆向flex-direction:row|row-recerse|column|column-reverse; 是否换行：（弹性容器）1flex-wrap:nowrap|wrap|wrap-reverse； 当设置为不换行时，会对弹性元素进行弹性收缩。 上面两个属性可以合成为：（弹性容器）1flex-flow:&lt;flex-derection&gt; || &lt;flex-wrap&gt;; 定义弹性元素的排列顺序，order值，大的排在后面；（弹性元素）1order:&lt;interger&gt;; // 整数，初始值为0； 弹性属性：设置弹性元素在main-axis上的宽度和高度；（弹性元素）1flex-basis:main-size|&lt;width&gt;; 设置剩余空间的分配比例，如item1的 flex-grow:1；item2的flex-grow:2;则剩余的空间则按1/3,2/3分配给item1和item2；（弹性元素）1flex-grow:&lt;number&gt;; // 初始值为0； 设置当空间不足时，按比例收缩弹性元素，与flex-grow相对应；（弹性元素）1flew-shrink:&lt;number&gt;; // 初始值为1; 组合起来，可以设置为：（弹性元素）12// 初始值为 0 1 main-sizeflew:&lt;flew-grow&gt;||&lt;flex-shrink&gt;||&lt;flex-basis&gt; 对齐属性：设置在主轴main-axis方向上的对齐方式。（弹性容器）1justify-content:flex-start|flex-end|center|space-between|space-around; flex-start：左对齐；flex-end：右对齐；center：居中；space-between：中间间隔平分；space-around：首尾也分到间隔（当都设置宽度，且有剩余空间时）； 设置辅轴cross-axis上的对齐（但弹性元素高度不一的时候）：（弹性容器）1align-items:flex-start|flex-end|center|baseline|strech; flex-start：上对齐；flex-end：下对齐；center：居中；baseline：内容对齐；strech：拉伸对齐； 设置单个弹性元素在cross-axis上的对齐属性：（弹性元素）1align-self:auto|flex-start|flex-end|center|space-between|space-around|stretch; 设置cross-axis方向上行对齐的方式：（弹性容器）1align-content:auto|flex-start|flex-end|center|space-between|space-around|stretch;","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"},{"name":"笔记","slug":"教程/笔记","permalink":"https://kmbk0.top/blog/categories/教程/笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://kmbk0.top/blog/tags/css/"}]},{"title":"减少HTTP请求","slug":"reduce-http-requests","date":"2019-08-14T05:10:00.000Z","updated":"2020-01-14T10:56:53.695Z","comments":true,"path":"2019/08/14/reduce-http-requests/","link":"","permalink":"https://kmbk0.top/2019/08/14/reduce-http-requests/","excerpt":"","text":"前言:关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精… 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议减少HTTP请求：“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。 a. 没有浏览器缓存减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。 b. 没有cdn缓存这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。 c. 不能按需加载为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。 d. 浏览器预解析DNS失效现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。 最佳实践因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。 Demo1 必应 首次内联CSS与JS 将资源取出，并保存在localStorage中 资源名（版本）保存在cookie中 后续请求中，服务器检查对应的cookie 根据cookie的值，只嵌入新的脚本 加载时，从localStorage里载入资源 Demo2 百度(移动端) 首次将静态资源打包，用jsonp统一返回 将资源解析并保存在localStorage中 再次访问时检查localStorage中资源情况 如有缺失再发请求获取资源 必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。","categories":[{"name":"教程","slug":"教程","permalink":"https://kmbk0.top/blog/categories/教程/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://kmbk0.top/blog/tags/html5/"},{"name":"前端","slug":"前端","permalink":"https://kmbk0.top/blog/tags/前端/"},{"name":"性能","slug":"性能","permalink":"https://kmbk0.top/blog/tags/性能/"}]}]}